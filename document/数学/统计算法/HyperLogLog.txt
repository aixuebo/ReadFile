常见的统计需求:
统计一个页面的uv数，在少量数据情况下,使用set或者hashmap都可以做到，但如果量大的情况下,会占用内存,甚至会oom,因此无法使用该方式。

总结:
通过实验,计算每一次出现正面的实验次数,选取最大的实验次数k,2^k表示样本size的估算值。

一、HyperLogLog 简称HLL.
1.不是精准的统计,会存在误差
2.用少量内存,采用估算的方式,去估算集合中不重复的数据数量。
3.bitmap会随着基数不同,产生容纳基数的更多的内存,但HyperLogLog不需要,一个固定的内存,可以兼容N多个基数的数量集,只是概率的准确性会有差异而已。
4.HLL(16)表示分桶数量2^16次方,分桶数量越多,误差会越小,大概算下来,HLL(16)的误差是1.22%。
因为每一个桶都需要分配6bit,因此桶越多,使用的内存总量也越多。


二、原理
1.HyperLogLog实际上不会存储每个元素的值,他只是计算一个概率。
伯努利实验
比如投硬币,直到第一次出现正面为止。表示一轮游戏结束，记录该论游戏投掷了多少次硬币。
即每一轮游戏,都对应一个投硬币次数。
进行了N论游戏,我们可以获得N个投掷硬币次数结果值。取最大的值,用kmax表示。

现在假设我不告诉你一共玩了多少回游戏,但我告诉你kmax是3次.即我最多投3次就出现了正面。那么问你能否知道我大概玩了多少回？答案是8回。

2.实验存在的问题
a.有可能第一次实验就玩了10次才出现正面，那kmax结果就是10.显然是不对的。因此引入了桶的概念，计算m个桶的加权平均值，这样就能得到比较准确的答案了（实际上还要进行其他修正）。
b.3次,最多玩8回，是有误差的，但随着玩的次数越多,这种方式统计的越准。比如玩100万次,大概率会出现投20次才出现正面的可能。

3.公式
R = m个kmax的调和平均值。
b = m个求和,每一个1/2^R
N = 常数 * m * (m/b)

m表示分桶数

总结:
R表示平均的kmax= 通过m个分桶的调和平均值,代表平均的kmax。
m/b 表示 调和平均数。
上面计算的是每一个分桶的容纳不重复元素数量,一共有m个分桶,因此要*m。
常数系数表示可以调节误差的参数。


类似抛硬币，假设我们生成的2进制hash值是64位，每一位都相当于抛了一次硬币，是0或者1都是随机的。
对于一个随机生成的64位hash值：
有1/2的概率第1位就是0
有1/4的概率第1位是1，第2位才是0
有1/8的概率前2位都是1，第3位才是0
有1/16的概率前3位都是1，第4位才是0
有1/32的概率前4位都是1，第5位才是0
有1/64的概率前5位都是1，第6位才是0
......
我们将待去重的所有值全部进行hash，假如有一个hash值一直到第10位才出现第一个0，对于一次独立重复实验（一次hash），这是一个小概率事件。
从概率上来讲，大概是进行2^10次独立重复实验才可能产生一个这样的hash值，于是我们可以合理推断，这些值去重后的量级为2^10=1024左右。
即如此小概率的事件都发生了,说明肯定有这些数量级的数据。属于极大似然原理。

三、Redis的实现
计算过程:
1.对于一个输入的字符串，首先得到64位的hash值。(通过哈希算法把输入的随机性增加)
2.64位分2部分,前14位用于定位分桶。2^14 = 16384,因此分成16384个桶。
如果前16位用于分桶,分桶数量就会更多,2^16。以此类推。
3.后50位(64-14)，用于记录伯努利kmax。即最多允许出现50次投掷才出现正面,即2^50次方。非常大了。而我们知道2^6=64,超过50,因此6个字节就可以存储有kmax。
即50位中,第一次出现1的位置,即为一次实验的kmax。
4.即每一个分桶内,如果遇到了更大的kmax,就替换。最终每一个分桶内,保留最大的kmax。

需要多少内存:
在14位用于分桶的情况下,使用总内存是 (16384 * 6) / 8 / 1024 = 12k,即12k可以容纳2^50次方的集合容量数量级。

四、扩展知识 -- redis如何实现存储的。
1.密集存储结构
使用连续的16384个6bit串成的字节位图。每一个桶占用6个bit。
那么如果通过一个已知的桶位置,定位他的6bit在哪个位置呢?
比如通过拿到14位，计算属于第3个桶(从0开始计数),那么他在内存的哪个位置呢?肯定在6+6+6+? 即从19bit开始的6位都属于他的。而一个字节=8bit,因此第19bit在第8+8+3的位置,即第3个字节第3个bit开始。
公式为:
 offset_bytes = (idx * 6) / 8 = 18 / 8 = 2;   
 offset_bits = (idx * 6) % 8 = 18 % 8 = 2.
 即在第2个字节,第2个bit上.因为都是从0开始算的，因此获取的就是第3个字节第3个bit开始。
 
 2.稀疏存储结构
你以为Redis真的会用16384个6bit存储每一个HLL对象吗，那就too naive了，虽然它只占用了12K内存，但是Redis对于内存的节约已经到了丧心病狂的地步了。因此，如果比较多的计数值都是0，那么就会采用稀疏存储的结构。
对于连续多个计数值为0的桶，Redis使用的存储方式是：00xxxxxx，前缀两个0，后面6位的值加1表示有连续多少个桶的计数值为0，由于6bit最大能表示64个桶，所以Redis又设计了另一种表示方法：01xxxxxx yyyyyyyy，这样后面14bit就可以表示16384个桶了，
而一个初始状态的HyperLogLog对象只需要用2个字节来存储。
如果连续的桶数都不是0，那么Redis的表示方式为1vvvvvxx，即为连续(xx+1)个桶的计数值都是(vvvvv+1)。例如，10011110表示连续3个8。这里使用5bit，最大只能表示32。因此，当某个计数值大于32时，Redis会将这个HyperLogLog对象调整为密集存储。

https://cloud.tencent.com/developer/article/1349691
