常见的统计需求:
统计一个页面的uv数，在少量数据情况下,使用set或者hashmap都可以做到，但如果量大的情况下,会占用内存,甚至会oom,因此无法使用该方式。

一、准确的统计方式。
1.如果统计的主键是字符串,将其映射成int,存储映射关系。
2.如果统计的主键就是int,直接存储即可。


二、demo
例如01101001，表示的是[1,2,4,8],即id为1 2 4 8的四个用户访问过该页面。


三、优点
1.省内存。一个元素只使用一个bit。统计1亿个数据的基数，需要的内存是：100000000/8/1024/1024 ≈ 12M。
2.bitmap也可以轻松合并多个集合，只需要将多个数组进行异或操作就可以了。
3.基于bitmap的操作,计算count也非常快。
4.可以精准的知道一个元素是否被存在在集合里。与set和hash相同。

缺点:
1.上面计算的一个页面对象需要12M，如果有1000个页面,就需要12G，有1万也页面,就需要120G，这个页面数量需求可能是非常多的,因此内存浪费也是很严重的。
因为必须要分配最大的容量内存,否则扩容很难。
这种方式的解决方案是HyperLogLog。

比如想看每一个商品的uv,商品数量可能是几百万,但每一个商品都分配12M是不太合理的。如果每一个商品分配12k,甚至更少,那就会节省很多内存。


四、扩展
Roaring Bitmap 的读写速度最快，存储效率也很高，目前已经在Spark，Drill等开源项目中使用。
我们还是以存放 Integer 值的 Bitmap 来举例，
Roaring Bitmap 把一个 32 位的 Integer 划分为高 16 位和低 16 位，
取高 16 位找到该条数据所对应的 key，每个 key 都有自己的一个 Container。
我们把剩余的低 16 位放入该 Container 中。


short[] keys;//前16位确定一个key
Container[] values;//每一个key对应一个容器,存储属于该key内的所有子元素

优点:
原来要存储大容量的元素,需要初始化一个大的容器,不管存储的真实情况是1个元素还是大量元素,这部分申请的内存都要用完.
如果改用Roaring Bitmap方式,没有用到的容量,就会被省略,用多少申请多少。同时又兼容了bitmap的优点,快速定位元素是否存在。

依据不同的场景，有 3 种不同的 Container，分别是 Array Container、Bitmap Container 和 Run Container

1.Array Container 适合存放稀疏的数据。
数据结构 short[] content;存储的元素放在short里面,因为short是2个字节,正好容纳16位。
内存数据结构就是一个固定的数组,这个 array 是有序的,可以二分查找，方便查找。
如果数组容量超过最大容量 4096 时，会转换为 Bitmap Container。

举例来说明数据放入一个 Array Container 的过程：
有 0xFFFF0000 和 0xFFFF0001 两个数需要放到 Bitmap 中, 它们的前 16 位都是 FFFF，所以他们是同一个 key，它们的后 16 位存放在同一个 Container 中;
它们的后 16 位分别是 0 和 1, 在 Array Container 的数组中分别保存 0 和 1 就可以了，相较于原始的 Bitmap 需要占用 512M 内存来存储这两个数，
这种存放实际只占用了 2(同一个key,因此是一个short)+4(key里面存储了2个值,因此是2个short) = 6 个字节。

2.Bitmap Container 适合存储稠密的数据。
每一个key 用8kb内存。
其内部就是一个Bitmap,long数组,存储1024个固定容量,即8*1024个字节的Bitmap,固定占用内存 8 KB（1024 * 8 Byte）。(不能扩容,因为Bitmap不允许扩容)
这边推导下 1024 这个值：由于每个 Container 还需处理剩余的后 16 位数据，使用 Bitmap 来存储需要 8192 Bytes（2^16/8）, 而一个 long 值占 8 个 Bytes，所以一共需要 1024（8192/8）个 long 值。

当 Array Container 中元素到 4096 个时，也恰好占用 8 k（4096*2Bytes）的空间，正好等于 Bitmap 所占用的 8 KB。
而当你存放的元素个数超过 4096 的时候，Array Container 的大小占用还是会线性的增长，但是 Bitmap Container 的内存空间并不会增长，始终还是占用 8 K，
所以当 Array Container 超过最大容量（DEFAULT_MAX_SIZE）会转换为 Bitmap Container。

3.Run Container 适用于存放连续的数据。比如说 1 到 100，一共 100 个数
这边的Run指的是Run Length Encoding(RLE),它对连续数据有比较好的压缩效果。
原理是对于连续出现的数字, 只记录初始数字和后续数量。例如: 对于 [11, 12, 13, 14, 15, 21, 22]，会被记录为 11, 4, 21, 1。
很显然，该 Container 的存储占用与数据的分布紧密相关。最好情况是如果数据是连续分布的，就算是存放 65536 个元素，也只会占用 2 个 short。
而最坏的情况就是当数据全部不连续的时候，存储65536个short,每一个short2个字节,因此会占用 128 KB 内存。


五、备注:
1.bitmap看似很省内存，但针对的是一行数据的一个字段，如果数据行数很多，那最终也是很多内存的。
同时为了让bitmap日后不扩展，起初就要给一个较大的内存，这是非常浪费的。

