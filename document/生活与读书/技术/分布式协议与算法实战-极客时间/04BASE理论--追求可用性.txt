一、背景与总结
1.基本可用（Basically Available）+ 最终一致性（Eventually consistent）。
也有人会提到软状态（Soft state），在我看来，软状态描述的是实现服务可用性的时候系统数据的一种过渡状态，也就是说不同节点间，数据副本存在短暂的不一致。
2.没有现成的框架支持最终一致性，需要自己基于业务逻辑去实现属于自己的最终一致性方式。

二、基本可用
1.概念解读
当分布式系统在出现不可预知的故障时，允许损失部分功能的可用性，保障核心功能的可用性。

2.案例 --- 通过牺牲响应时间的可用性，保障核心功能的运行。
流量削峰：12306订票系统，可以在不同的时间，出售不同区域的票，将访问请求错开，削弱请求峰值。
延迟响应：在春运期间，自己提交的购票请求，往往会在队列中排队等待处理，可能几分钟或十几分钟后，系统才开始处理，然后响应处理结果。
体验降级：用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。
过载保护：队列满了之后，就清除队列中一定数量的排队请求，保护系统不过载。

基本可用在本质上是一种妥协，也就是在出现节点故障或系统过载的时候，通过牺牲非核心功能的可用性，保障核心功能的稳定运行。

三、最终的一致 --- 系统中所有的数据副本在经过一段时间的同步后，最终能够达到一个一致的状态
1.在实际工程实践中有这样几种方式：
以最新写入的数据为准，比如AP模型的KV存储采用的就是这种方式；
以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。
2.具体实现方式
a.读时修复：在读取数据时，检测数据的不一致，进行修复。
比如Cassandra 的Read Repair实现，具体来说，在向Cassandra系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。
b.写时修复：在写入数据，检测数据的不一致时，进行修复。
比如Cassandra 的Hinted Handoff实现。具体来说，Cassandra集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。
c.异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。

3.备注
在这里，我想强调的是因为写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，所以我推荐你在实现最终一致性时优先实现这种方式。
而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，在开发实际系统时，你要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响。

