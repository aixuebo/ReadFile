一、背景与总结
1.核心的问题是有叛徒，而这个又是最难解决的。很多协议都不是真正的拜占庭问题，因为很多协议都是假设信息不会被篡改前提下完成的。
2.要解决的问题
一致性问题:要么一起进攻、撤退；
安全问题:确保信息不会被篡改。
3.如果叛将人数为m，将军人数不能少于3m + 1 ，那么拜占庭将军问题就能解决了。（n位将军，最多能容忍(n - 1) / 3位叛将）

二、二忠一叛的难题
有敌人会篡改信息，这样在少数服从多数投票中，会存在问题。
1.解决问题方案一 ---- 口信消息型拜占庭问题之解
a.设置默认命令，比如撤退，未收到信息，则默认为撤退。
并且从所有将军中选择出一个leader。
b.第一轮协商，确定预先选择好的leader，将命令发送给其他将军。
c.第二轮协商，将军此时肯定有自己的命令。
比如:将军收到命令/未收到则有默认命令。
将军之间互发命令给其他人(注意，不要再发给leader了)。
d.最终第二轮的每一个将军按照少数服从多数，执行命令。

2.举例 -- 假设1个leader、3个将军，其中1个将军是叛徒。leader发送进攻。
a.在第一轮作战信息协商中，向齐、楚、燕发送作战指令“进攻”。
b.在第二轮协商中，虽然楚是叛徒，无论他是否篡改信息，其他两个节点肯定收到的大多数都是进攻，所以行动会一致。

注意: 一致性问题，不是指代叛徒也按照一致性进行进攻，而是非叛徒要一致性执行。（这个可能是拜占庭将军理解必须全部进攻的一个误区）

3.举例 -- 如果leader是有问题的，3个将军是没有问题的。
a.在第一轮作战信息协商中，leader向楚发送作战指令“进攻”，向齐、燕发送作战指令“撤退”。
b.在第二轮作战信息协商中，楚、齐、燕分别作为指挥官，向另外两位发送作战信息。三者都会大多数拿到撤退命令，所以少数服从多数，三者都一致性撤退。

4.结论
如果叛将人数为m，将军人数不能少于3m + 1 ，那么拜占庭将军问题就能解决了。（n位将军，最多能容忍(n - 1) / 3位叛将）

在二忠一叛的问题中，在存在1位叛将的情况下，必须增加1位将军，将3位将军协商共识，转换为4位将军协商共识，这样才能实现忠诚将军的一致性作战计划。
那么有没有办法，在不增加将军人数的时候，直接解决二忠一叛的难题呢？

三、解决问题方案二 ---- 签名消息型拜占庭问题之解 ---- 是一些常用的拜占庭容错算法（比如PBFT）的实现基础。
二忠二叛问题，更复杂一些。
1.原理
签名消息拜占庭问题之解，之所以能够容忍任意数量的叛徒，关键就在于通过消息的签名，约束了叛徒的作恶行为，也就是说，任何篡改和伪造忠将的消息的行为，都会被发现。将伪造信息忽略即可。


结论
1.虽然实现了忠将们作战计划的一致性，但它不关心达成共识的结果是什么。
他能够让大家意见达成一致，因为按照某一个规则大家获取数据，所以一致性是保证的，但可能最终结果不是leader期望的命令。
因为没有限制叛徒数量，所以极端情况，可能大多数人都叛徒了。
在我看来呢，这个算法解决的是共识的问题，没有与实际场景结合，是很难在实际场景中落地的。


四、算法分类
1.故事里的各位将军，你可以理解为计算机节点；
忠诚的将军，你可以理解为正常运行的计算机节点；
叛变的将军，你可以理解为出现故障并会发送误导信息的计算机节点；
信使被杀，可以理解为通讯故障、信息丢失；
信使被间谍替换，可以理解为通讯被中间人攻击，攻击者在恶意伪造信息和劫持通讯。

2.而在计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（Crash Fault Tolerance，CFT）。
CFT解决的是分布式的系统中存在故障，但不存在恶意节点的场景下的共识问题。 
也就是说，这个场景可能会丢失消息，或者有消息重复，但不存在错误消息，或者伪造消息的情况。常见的算法有Paxos算法、Raft算法、ZAB协议。

