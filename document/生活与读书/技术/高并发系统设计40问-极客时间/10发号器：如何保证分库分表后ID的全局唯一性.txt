一、背景与总结
1.某一个微服务，在数据体量大的时候，会分库分表解决单库的读写性能问题。
但数据分布在多个数据库里，如何确保主键唯一性呢？



二、数据库的主键，应该如何选择类型呢？背后是如何思考的
1.使用业务主键？
不推荐，因为业务如果未来发生变化，会影响主键。
比如用户表，主键可以是email或者手机号，但未来手机号和email发生变化，怎么办?会不会有其他影响。
为什么现在人不愿意换手机，因为很麻烦，好多地方都要解绑。

2.创建唯一的ID，与业务无关的，作为主键，是推荐的。
平时自增长就够了。

3.为什么不用UUID呢?
一般会使用它生成Request ID来标记单次请求，但不会作为数据库的主键。原因如下:
a.B+树，存储的是索引信息，而索引信息要有固定的长度是核心重要的，字符串不是好的推荐方式。虽然UUID也是有固定长度的。
b.ID要有单调递增性，UUID不具备这个特点。
查询系统的时候，比如查询评论系统，按照评论时间排序，其实可以转换成按照评论ID主键排序，有时候会更简化开发。
B+树特点，每一层的树上索引是有顺序的，因此如果本身id是递增的，则只需要再B+树节点追加记录即可，不需要对B+树格式有重新排序的移动开销影响，因此插入性能更高。同时磁盘的顺序写效率也比随机写效率高。
c.UUID是随机字符串，没有特殊的意义。ID如果是字符串，最好有一些意义。
比如拿到ID后，可以反解析出他是哪个服务器创建的ID，大概在什么时间段创建的，为哪个业务创建的ID，用于排查问题。
d.UUID是由32个16进制数字组成的字符串，如果作为数据库主键使用比较耗费空间。


三、如何创建分布式的唯一ID -- 基于Snowflake算法搭建发号器
1.Snowflake核心思想
不仅算法简单易实现，也满足ID所需要的全局唯一性，单调递增性，还包含一定的业务上的意义。

输出使用64bit的整数，每一个部分都有自己的含义，比如说时间戳、机器ID、服务、序列号等等，最终生成全局唯一的有序ID。
0(不用)
41bit用于表示时间戳，可以使用69年。
3bit表示机房，可以扩展有8个机房。
3bit表示机器服务器，支持8台发号器。
4bit表示业务ID，支持16个业务分发ID。
12bit表示序号，每个节点每毫秒最多可以生成4096的ID。

即最高有8个机房 * 8台服务器分发ID，每秒可以发 64台服务器 * 4096 = 262144，即26万+。
其实已经非常多了，而且基本上一个ID分发器，不需要浪费这么多服务器。


2.工业上实现
a.显然是不需要这么多机房、以及服务器，因此可以给业务ID和序号更多的bit位。
b.分发器序号，其实可以写到配置文件里，毕竟机器不需要太多。这样就可以保证每一台机器的序号ID是唯一的。
c.性能上单实例单CPU可以达到两万每秒。

3.如果分发器的QPS不高，比如说发号器每毫秒只发一个ID，就会造成生成ID的末位永远是1，那么在分库分表时如果使用ID作为分区键就会造成库表分配的不均匀。
解决办法主要有两个：
a.时间戳不记录毫秒而是记录秒，这样在一个时间区间里可以多发出几个号，避免出现分库分表时数据分配不均。
b.生成的序列号的起始号可以做一下随机，这一秒是21，下一秒是30，这样就会尽量地均衡了。

4.为什么Snowflake能做到单调递增呢？
首先时间戳部分，肯定是递增的。
机房和服务器是写到配置文件里的，固定值，不影响单调递增性。
业务ID虽然是不同的，但每一个业务确保主键是单调递增即可，而此时业务ID是固定值。
序号肯定也是单调递增的。

因此结论是，如果主键只能去某一个固定的发号器取数据，由于机房和服务器是固定的，所以一定是单调递增的。
而如果一个业务去多个发号器取数，确实很难做到单调递增。
工业上，确实针对某一个微服务，从固定的一个分发器取数就够了。


