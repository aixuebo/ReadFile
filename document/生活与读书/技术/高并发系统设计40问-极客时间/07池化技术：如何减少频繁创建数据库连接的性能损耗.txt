一、背景与总结
1.池化技术:
一种常见的软件设计思想，叫做池化技术，它的核心思想是空间换时间，期望使用预先创建好的对象来减少频繁创建对象的性能开销，同时还可以对对象进行统一的管理，降低了对象的使用的成本。

二、不使用数据库连接池，为什么就会慢了。如何评估慢了多少？
1.用"tcpdump -i bond0 -nn -tttt port 4490"命令抓取了线上MySQL建立连接的网络包来做分析，从抓包结果来看，整个MySQL的连接过程可以分为两部分：
第一部分是TCP的三次握手过程。
第二部分是MySQL服务端校验客户端密码的过程。

这两个部分，耗时4ms，而sql查询耗时1ms。
因此1s的时间，只能执行200个sql，其中80%的时间用在了连接上。
如果用数据库连接池后，只需要执行sql1ms，因此1s可以执行1000个sql，性能提升5倍。

三、连接池原理
1，数据库连接池有两个最重要的配置：最小连接数和最大连接数，它们控制着从连接池中获取连接的流程：
如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；
如果连接池中有空闲连接则复用空闲连接；
如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；
如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0的连接池配置是checkoutTimeout）等待旧的连接可用；
如果等待超过了这个设定时间则向用户抛出错误。


2.连接池中的链接可能发生故障，原因如下:
a.数据库的域名对应的IP发生了变更，池子的连接还是使用旧的IP，当旧的IP下的数据库服务关闭后，再使用这个连接查询就会发生错误；
b.MySQL有个参数是“wait_timeout”，控制着当数据库连接闲置多长时间后，数据库会主动地关闭这条连接。所以当我们使用这个被关闭的连接时就会发生错误。

3.如何保证连接池中连接是可用的呢？
a.启动一个线程来定期检测连接池中的连接是否可用，比如使用连接发送“select 1”的命令给数据库看是否会抛出异常，
如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。目前C3P0连接池可以采用这种方式来检测连接是否可用，也是我比较推荐的方式。

b.在获取到连接之后，先校验连接是否可用，如果可用才会执行SQL语句。比如DBCP连接池的testOnBorrow配置项，就是控制是否开启这个验证。
这种方式在获取连接时会引入多余的开销，在线上系统中还是尽量不要开启，在测试服务上可以使用。

四、ThreadPoolExecutor要注意的内容
1.ThreadPoolExecutor流程
JDK 1.5中引入的ThreadPoolExecutor就是一种线程池的实现，
它有两个重要的参数：coreThreadCount和maxThreadCount，这两个参数控制着线程池的执行过程。它的执行原理，我这里再给你描述下，以加深你的记忆：
如果线程池中的线程数少于coreThreadCount时，处理新的任务时会创建新的线程；
如果线程数大于coreThreadCount则把任务丢到一个队列里面，由当前空闲的线程执行；(注意，他不是创建新线程去执行，而是放到队列里了)
当队列中的任务堆积满了的时候，则继续创建线程，直到达到maxThreadCount；(注意:只有队列满的时候，才会去创建新线程执行，如果队列是无边界队列，那就一直占用内存,最后OOM)
当线程数达到maxTheadCount时还有新的任务提交，那么我们就不得不将它们丢弃了。

2.有很多坑点
a.首先，JDK实现的这个线程池优先把任务放入队列暂存起来，而不是创建更多的线程，它比较适用于执行CPU密集型的任务，也就是需要执行大量CPU运算的任务。这是为什么呢？
因为执行CPU密集型的任务时CPU比较繁忙，因此只需要创建和CPU核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。
所以当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来。
但是，我们平时开发的Web系统通常都有大量的IO操作，比方说查询数据库、查询缓存等等。
任务在执行IO操作的时候CPU就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。
所以你看Tomcat使用的线程池就不是JDK原生的线程池，而是做了一些改造，当线程数超过coreThreadCount之后会优先创建线程，直到线程数到达maxThreadCount，
这样就比较适合于Web系统大量IO操作的场景了，你在实际使用过程中也可以参考借鉴。

b.其次，线程池中使用的队列的堆积量也是我们需要监控的重要指标，对于实时性要求比较高的任务来说，这个指标尤为关键。
我在实际项目中就曾经遇到过任务被丢给线程池之后，长时间都没有被执行的诡异问题。
最初，我认为这是代码的Bug导致的，后来经过排查发现，是因为线程池的coreThreadCount和maxThreadCount设置得比较小，
导致任务在线程池里面大量的堆积，在调大了这两个参数之后问题就解决了。
跳出这个坑之后，我就把重要线程池的队列任务堆积量，作为一个重要的监控指标放到了系统监控大屏上。

c.如果你使用线程池请一定记住不要使用无界队列。
也许你会觉得使用了无界队列后，任务就永远不会被丢弃，只要任务对实时性要求不高，反正早晚有消费完的一天。
但是，大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发Full GC，造成服务不可用，我之前排查过的一次GC引起的宕机，起因就是系统中的一个线程池使用了无界队列。
