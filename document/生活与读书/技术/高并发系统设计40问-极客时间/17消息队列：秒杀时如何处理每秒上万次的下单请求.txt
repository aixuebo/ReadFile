一、背景与总结
1.高并发写请求的场景中，比如秒杀。特点是读请求极高，写请求也很大，但能允许成功写入的请求很少，比如就200单。
2.消息队列的作用
a.高峰流量削峰，减少数据库压力。
b.实现异步处理来简化秒杀请求中的业务流程，提升系统的性能。
c.解耦合


二、如何解决秒杀 --- 消息队列消峰处理
1.查询热点商品，尽量组织他们访问底层数据库
静态资源:图片和视频,命中CDN节点缓存,即直接从CDN读取数据，不让到web服务器，因此减少Web服务器的查询量和带宽负担。
动态资源:到web服务器后,比如到Nginx,直接访问分布式缓存，避免到应用服务器，比如tomcat。
限流策略:对短时间之内来自某一个用户、某一个IP或者某一台设备的重复请求做丢弃处理。减少到达应用服务器请求。

2.开始秒杀 --- 此时肯定会访问数据库生成订单
瞬间流量突增，请求生成订单、扣减库存，不可能经过缓存，而是直接操作数据库。
1秒钟之内，有1万个数据库连接同时达到，系统的数据库濒临崩溃。

3.消息队列解耦 --- 商品数量就这么多，先到先得的原则，进入队列，但顺序的写入数据库，这样数据库写压力没有那么大，只要有一个队列可以写性能高，顺序写入磁盘保存优先顺序即可。
我理解的消息队列:暂时存储数据的一个容器,认为它是一个平衡低速系统和高速系统处理任务时间差的工具。
比如:
a.Java线程池使用一个队列来暂时存储提交的任务，等待有空闲的线程处理这些任务；
b.实现一个RPC框架时，也会将从网络上接收到的请求写到队列里，再启动若干个工作线程来处理。

削去秒杀场景下的峰值写流量:
将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后再处理其它用户的请求。
我们会在后台启动若干个队列处理程序消费消息队列中的消息，再执行校验库存、下单等逻辑。
因为只有有限个队列处理线程在执行，所以落入后端数据库上的并发请求是有限的。
而请求是可以在消息队列中被短暂地堆积，当库存被消耗完之后，消息队列中堆积的请求就可以被丢弃了。

虽说堆积会造成请求被短暂延迟处理，但是只要我们时刻监控消息队列中的堆积长度，
在堆积量超过一定量时，增加队列处理机数量来提升消息的处理能力就好了，而且秒杀的用户对于短暂延迟知晓秒杀的结果也是有一定容忍度的。

需要做好评估，比如有多少个商品会被秒杀，比如1000件，假设数据库写压力是100，那么就需要10台数据库。
总之消息队列只是解决了高流量不会一下子涌入数据库，只让有效的写消息进入到数据库，而数据库必须满足此次秒杀需要的环境，即几秒内返回给前几名用户的结果，此时数据库是必须要满足这个条件的。

三、通过异步处理简化秒杀请求中的业务流程 -- 消息队列除了"削峰"外,还可以实现异步处理来简化秒杀请求中的业务流程，提升系统的性能。
你想，在刚才提到的秒杀场景下，我们在处理购买请求时需要500ms。这时你分析了一下整个的购买流程，发现这里面会有主要的业务逻辑，也会有次要的业务逻辑：
比如说，主要的流程是生成订单、扣减库存；次要的流程可能是我们在下单购买成功之后会给用户发放优惠券，会增加用户的积分。
假如发放优惠券的耗时是50ms，增加用户积分的耗时也是50ms，那么如果我们将发放优惠券、增加积分的操作放在另外一个队列处理机中执行，那么整个流程就缩短到了400ms，性能提升了20%。
处理这1000件商品的时间就变成了400s。如果我们还是希望能在50s之内看到秒杀结果的话，只需要部署8个队列程序就好了。

四、解耦实现秒杀系统模块之间松耦合 -- 消息队列 解耦合
比如实时统计秒杀活动，
a.耦合方案 -- 将数据通过HTTP或者RPC的方式，异步/同步给数据团队的接口。
因为会存在问题:
整体系统的耦合性比较强，当数据团队的接口发生故障时，会影响到秒杀系统的可用性。
当数据系统需要新的字段，就要变更接口的参数，那么秒杀系统也要随着一起变更。
b.解耦合方案
数据团队直接订阅消息队列即可。
其实异步处理也是一种解耦的场景。

整体流程图:
业务服务器 --> 消息对垒 <-- 业务处理 ---> 数据库(核心业务) 
								 ---> 消息队列(非核心业务)(异步解耦) <--- 积分服务
								 ---> 消息队列(数据解耦) <-- 数据组统计 


