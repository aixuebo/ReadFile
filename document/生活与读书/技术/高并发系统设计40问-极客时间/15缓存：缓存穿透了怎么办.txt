一、背景与总结
1.经过前两节，还能有什么问题吗?
经过前两节，已经解决了以下问题
a.数据+缓存的一致性问题，即存储到缓存的数据是可用的。
b.缓存是高可用的，可以相信他可以帮我们稳定的拦截流量，避免透传到数据层。

但是否还有使用缓存的过程中，依然会穿透缓存，到达数据库的场景呢？要如何解决呢？

2.定义
a.缓存穿透：缓存查询不到数据，需要从数据库查询。
b.缓存并发:并发同时查询同一个key，此时缓存失效，并发的请求同时查询数据库。

3.穿透的场景
a.查询非法的无效数据。
b.缓存并发。
c.缓存失效。


二、缓存穿透 -- 绕过缓存,直接到数据库查询
1.指标抓书：对于缓存来说命中率是它的生命线
在低缓存命中率的系统中，大量查询商品信息的请求会穿透缓存到数据库，会造成数据库性能下降，阻塞服务请求，使服务器连接和线程资源被占满，导致应用系统崩溃。
核心系统缓存命中率要在99%+，非核心也要保证90%+。如果低于这个标准你可能就需要优化缓存的使用方式了。

2.少了缓存穿透是合理的
因为全量的数据放到缓存是不合理的，缓存也存不下；缓存只需要存储最核心的20%热点数据即可。

三、缓存穿透场景与解决方案 --- 查询数据本身就不存在
1.背景
如果查询的数据本身就不存在，比如查询用户信息，但传入参数的用户id根本就不存在。
这种场景肯定缓存是失效，会查询数据库，造成数据库压力。

2.解决方案 -- 数据校验
传入数据库前，通过id查询数据库是否存在。该数据库可以是redis或者数据库，因为有索引 + 分库分表，所以理论上不会给数据库造成压力。避免非法数据有过多的查询query产生。

3.解决方案 -- 回种空值
当我们从数据库中查询到空值或者发生异常时，我们可以向缓存中回种一个空值。但是因为空值并不是准确的业务数据，并且会占用缓存的空间，所以我们会给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰。
下面是这个流程的伪代码：
Object nullValue = new Object();
try {
  Object valueFromDB = getFromDB(uid); //从数据库中查询数据
  if (valueFromDB == null) {
    cache.set(uid, nullValue, 10);   //如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间
  } else {
    cache.set(uid, valueFromDB, 1000);
  }
} catch(Exception e) {
  cache.set(uid, nullValue, 10);
}

缺点:
a.只能case by case解决，
b.如果大量不同的数据请求，每次依然会穿透，缓存的数据不会被再次查询，因此该方案也没有太多效果；
c.虽然缓存了10s，但10s内不再次发送请求，依然没有彻底解决该问题。
d.存储这种无效空值，占用缓存空间。而且还会剔除掉有效的缓存数据，从而降低了缓存命中率。


4.解决方案 -- 布隆过滤器
①基础信息
a.与方案1--数据校验类似，只是使用更少空间的方案。
b.写:初始化布隆过滤器，把所有数据存放到过滤器里 ---> 新增的数据要同步数据库的同时，也要插入到布隆过滤器里。
c.读:查询缓存前，先查询过滤器，确保合法再查看缓存。

②原理与缺陷
a.原理:
每一个数据占用一个bit,占用存储空间小。
使用多次hash函数，让不同的bit位数据设置为1.如果全部数据都是1，则说明命中布隆过滤器。
如果数据不在过滤器内，说明一定是非法数据。如果数据在过滤器内，也有可能是非法数据（说明hash冲突了），为了降低hash冲突的概率，多创建几个hash函数即可。

b.缺点
它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中；
不支持删除元素。

四、缓存穿透场景与解决方案 --- 缓存并发 --- 狗桩效应dog-pile effect -- 热点数据并发查询造成数据库风险
1.狗桩效应dog-pile effect 背景
当热点数据缓存失效，由于热点数据访问量大，会并发的产生很多次请求，而此时缓存失效，这些请求都会发送到数据库,给数据库造成瞬时压力。
2.解决思路:减少缓存穿透后的并发
即相同的查询，只查询一次数据库，其他的查询等待查询缓存即可。

分布式锁方案:
请求A ---> 缓存失效 穿透 ---> 可以拿到分布式锁 即查看缓存key是否有锁 ---> 向缓存中存储key=lock --> 请求数据库 --> 更新缓存 ---> 删除分布式锁的key内容 ### 注意catch finally中一定要将分布式锁解除
请求B ---> 缓存失效 穿透 ---> 缓存key有锁,说明缓存key在请求数据库中 ---> sleep ---> 重新查询缓存流程 ----> 设置重试次数，超过次数返回客户端无数据。

五、缓存穿透场景与解决方案 -- 缓存失效
1.背景
缓存设置的时候，设置了有效期，而大量的缓存同时到期，在并发量大的时候，会同时对数据库造成压力。
2.解决方案
在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。


六、网上扩展信息学习
1.如何解决数据穿透以及数据并发带来的问题
a.并发高的时候，不太建议使用缓存过期这个策略的，而是希望缓存一直存在，这样避免缓存穿透，存储量上需要评估一下。
注意：更新缓存之前，缓存中依然有旧数据，所以不会造成缓存穿透
b.后台系统，通过记录数据库更新的binlog或者log日志，启动job定时任务，将数据库变更的信息同步到缓存中，从而达到最终一致性。
c.如果缓存系统挂了，或者更新缓存的时候失败了，重试几次，如果还失败，则记录到消息队列中。不断从消息队列更新缓存。
注意:消息队列和正常数据库变更log的优先关系顺序问题。

2.热点数据缓存
a.怎么识别什么是热点数据
新创建一个热点数据缓存，该队列是一个有限+可排序队列。存储热点的key+value。
支持10万个热点id(基本这个体量就够热点的总体量了，可以认为热点不会超过10万个)
按照访问顺序，倒序排序。
b.每次操作任何数据，都更新热点队列，如果热点队列满了，就删除热点key。同时把热点key对应的value也删除。
c.查询时，优先查询热点集群，如果查询不到，则查询正常的集群获取数据。

