一、背景与总结
1.由于数据库做了分库分表、以及主从复制。本身数据库是可以承受一定高峰压力了。
但支撑QPS为10万，甚至百万，还是不可能的，尽量避免操作数据库，可以在数据库前增加一层缓存，查询缓存即可。

2.缓存应用在读多写少的场景是最为合适的。
否则会出现各种缓存穿透、缓存并发等问题。缓存+数据库的一致性问题，解决起来还是非常难的。


二、HTTP协议的缓存case
a.当第一次请求图片的时候，服务器返回图片内容，同时还有"Etag"字段，比如Etag=2e681a-6-5d044840。即服务器为该图片资源生产了一个唯一码。
b.浏览器在本地缓存图片与Etag。
c.下一次再访问该图片时,浏览器请求头 "If-None-Match=Etag"信息发送给服务端，服务端对比图片是否发生变化，如果没有变化，则返回304，浏览器使用缓存的图片即可。
通过这种缓存协商的方式，可以减少网络传输的数据大小，从而提升页面展示的性能。


三、缓存与缓冲区区别
缓存，在高速访问区内查询数据，避免进入低速访问区查询；可以提高低速设备的访问速度，或者减少复杂耗时的计算带来的性能问题。
缓冲区，是一块临时存储数据的区域，这些数据后面会被传输到其他设备上。
	缓冲区更像“消息队列篇”中即将提到的消息队列，用以弥补高速设备和低速设备通信时的速度差。
	比如，我们将数据写入磁盘时并不是直接刷盘，而是写到一块缓冲区里面，当经过一定时间或者脏缓冲区比例到达一定阈值时，由单独的线程把脏块刷新到硬盘上。这样避免了每次写数据都要刷盘带来的性能问题。

四、缓存分类
1.静态缓存。直接存储在Nginx或者cdn上，顺序读取静态磁盘内容。大概率都不会到服务器上，也不会命中服务器的内存缓存。
2.分布式动态缓存,比如Memcached、Redis。
3.热点本地缓存。
当我们遇到极端的热点数据查询的时候。热点本地缓存主要部署在应用服务器的代码中，用于阻挡热点查询对于分布式缓存节点或者数据库的压力。
我们会在代码中使用一些本地缓存方案，如HashMap，Guava Cache或者是Ehcache等，它们和应用程序部署在同一个进程中，优势是不需要跨网络调度，速度极快，所以可以用来阻挡短时间内的热点查询。
为了防止数据本身一会发生变化，因此设置每隔30秒重新从数据库中加载最新的所有数据。


由于本地缓存是部署在应用服务器中，而我们应用服务器通常会部署多台，当数据更新时，我们不能确定哪台服务器本地中了缓存，更新或者删除所有服务器的缓存不是一个好的选择，所以我们通常会等待缓存过期。
因此，这种缓存的有效期很短，通常为分钟或者秒级别，以避免返回前端脏数据。

五、缓存的不足
a.缓存只适用于读多写少的场景，如果并发频繁变更的数据被缓存，带来数据一致性问题，很难解。
b.缓存给系统带来了复杂度，需要解决数据不一致的问题。也要考虑缓存失败，数据库更新成功的场景。
c.缓存使用内存，而内存不能无限扩展。因此要有缓存失效方案。

