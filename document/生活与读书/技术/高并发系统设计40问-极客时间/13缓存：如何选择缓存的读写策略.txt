一、背景与总结
1.上节课讲到缓存在写少读多场景，最好用，但如果读多，写也多呢，此时如何做到缓存的高可用以及如何应对缓存穿透。
2.缓存与数据库双写的时候，一致性是一个难题。
3.实际场景还是使用Cache Aside（旁路缓存）策略居多，并且Cache Aside（旁路缓存）策略已经可以满足需求了。
没必要使用“Read/Write Through（读穿/写穿）策略”、“Write Back（写回）策略”。

使用Cache Aside策略足够了，原因是我个人不认为 数据库与缓存的强一致性 与 缓存的数据频繁变更 同时存在的场景。
所以可以牺牲短暂的一致性问题，使用最终一致性去解决缓存与数据库的双写一致性。

二、读缓存并不简单。
1.为什么觉得简单
只需要优先读缓存，缓存不命中就从数据库查询，查询到了就回种缓存。其实这种认知在细节上会存在很多问题。

2.不同场景，需要选择不同的缓存的读写策略，从而减少问题带来的麻烦。
a.缓存中是否有可能被写入脏数据。
b.策略的读写性能如何。
c.是否存在缓存命中率下降的情况。


三、Cache Aside（旁路缓存）策略
1.背景
有用户表，里面包含用户id、年龄，将用户id作为key，年龄做为value缓存。
当更新用户id=1,年龄从19更新到20，该如何做？

2.方案1
a.方案内容:先更新数据库，在更新缓存。
b.结论:数据会存在不一致情况。
c.并发产生的数据不一致过程:
	请求A ---> 更新用户1年龄为20。
	请求B ---> 更新用户1年龄为21。
	请求B ---> 更新缓存年龄为21。
	请求A ---> 更新缓存年龄为20。
	结论:数据库是21，缓存是20
d.产生问题的原因
数据库+缓存并不是在同一个事务里，跨系统也不能再一个事务里(引入分布式事务，成本较大，不划算)。
e.解决方案
更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。
客户端 ---> 更新数据库 ---> 删除缓存。
客户端查询缓存 ---> 未命中 查询数据库 --->写回缓存。

f.Cache Aside策略 -- 写策略
更新数据库中的记录；
删除缓存记录。

注意:
①.不能先删除缓存，在写数据库，这样也会数据不一致。
case:
当前数据库年龄为20。
请求A ---> 删除缓存
请求B ---> 读取数据，缓存未命中，查询数据库，年龄20 ---> 更新缓存
请求A ---> 更新数据库用户1年龄为21。
结论:数据库21，缓存20

②.那更新数据库，再删除缓存就不会有问题了吗?也会有问题，只是理论上会有问题，实际上概率很低，所以可忽略。
case:
当前数据库年龄为20。
请求A ---> 读取数据，缓存未命中，查询数据库，年龄20 ---> 此时还尚未更新缓存。 (理论上该操作很快)
请求B ---> 更新数据库年龄21，并且清空缓存。(理论上该操作很慢，至少慢于A对缓存的操作)
请求A ---> 更新缓存为20。
结论:数据库21，缓存20

但由于更新缓存是很快的操作，而更新数据库+情况缓存是相对慢的操作，所以理论上一定会缓存先被更新20，后因为数据库更新21而删除缓存。所以大概率不会发生数据不一致的情况。

g.Cache Aside策略 -- 读策略
从缓存中读取数据；
如果缓存命中，则直接返回数据；
如果缓存不命中，则从数据库中查询数据；
查询到数据后，将数据写入到缓存中，并且返回给用户。

h.返回到背景下，是否已经解决了该问题。
请求A ---> 更新用户1年龄为20。
请求B ---> 更新用户1年龄为21。
请求B ---> 删除缓存年龄为21。
请求A ---> 删除缓存年龄为20 --- key不存在，等于没有该操作。
结论:数据库是20.缓存无。而写操作确实不需要更新缓存。当下一次读时，在更新缓存即可。

3.Cache Aside策略是我们日常开发中最经常使用的缓存策略。不过他也有不适合的场景
a.新用户注册时，按照该策略，写入数据库+清空缓存。但此时缓存本身就没有新用户信息，等于白清理。
同时用户接下来要返回用户信息页面，即读取用户信息。因为数据库是主从分离的，有可能读取从库是读取不到用户信息的，从而数据库+缓存依然没有该用户信息。

解决方案:
插入数据+更新缓存。这样数据就可以从缓存读取数据。
主要是新用户场景可以这么操作，新用户注册，不会出现并发写入缓存的情况，所以不存在数据一致性问题。

b.读多写少的场景，肯定Cache Aside策略是合适的，但如果写很频繁呢？该如何解决？
当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：
①更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
同时引入分布式锁，开发成本上也有影响。
②也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。

4.总结
使用Cache Aside策略足够了，原因是我个人不认为 数据库与缓存的强一致性 与 缓存的数据频繁变更 同时存在的场景。
所以可以牺牲短暂的一致性问题，使用最终一致性去解决缓存与数据库的双写一致性。

a.很多场景，读多写少，那么直接使用Cache Aside策略就可以，因为用户也对一致性敏感度低。
比如 用户看商品信息，不需要那么实时准确。
b.写频繁的时候，都应该给缓存加一个过期时间，这样长期看会最终缓存与数据库是一致性的。
c.给缓存加过期时间确实可以解决很多问题，但会造成缓存穿透问题，有可能在极端情况下大量请求穿透缓存，到数据库，给数据库崩溃，从而导致系统崩溃。
所以在设置过期时间时要考虑场景是否会有穿透风险。
d.比如更新电商的商品数量，有必要缓存与数据库一致吗？
我感觉也不需要，数据库是最后一道门槛，缓存只是帮数据库阻拦一部分流量。
那么直接在redis里扣减库存，定期从数据库同步最准确的库存信息，回刷redis即可。即是redis没控制住，到数据库层也会控制住超卖问题。
e.首次请求数据一定不会再缓存里，这样会读取数据库，尤其在热点数据上，会频繁读取数据库，不划算。
解决方法是将热点数据同步放到缓存里。可以有一个定时任务，同步挖掘热点数据，回刷到缓存里。

四、Read/Write Through（读穿/写穿）策略
1.Cache Aside策略会产生一致性问题，本质原因是客户端既操作数据库，又操作缓存，无法在一个事务内完成。
Read/Write Through的思路key解决这个问题。
2.Read/Write Through的思路
用户只与缓存打交道，缓存进行更新缓存，并且缓存系统将缓存内的数据写入数据库/读取数据库。
核心关键词是 同步操作。

3.写策略
命中缓存 --> 更新缓存 --> 缓存组件同步更新数据库。
未命中缓存 -->缓存组件直接同步更新数据库。
4.读策略
命中缓存 --> 缓存读取数据 ---> 返回客户端。
未命中缓存 --> 缓存组件直接同步数据库信息，并且存储在缓存里 ---> 返回客户端。

5.策略特点与注意事项
a.核心关键词是 同步操作。所以对写吞吐量有影响。
那么我们可否异步地更新数据库？这就是我们接下来要提到的“Write Back”策略。
b.实际场景比较少见。原因是我们用的都是分布式缓存组件，比如redis，他本身不提供写入数据库/自动加载数据库的能力。
而我们在使用本地缓存的时候可以考虑使用这种策略，比如说在上一节中提到的本地缓存Guava Cache中的Loading Cache就有Read Through策略的影子。
但实际上本地缓存又不能这么用，因为本地缓存只是能为本地负责，没有办法做到其他节点缓存负责，所以使用场景受限。
比如本地更新数据，同步写数据库，但其他节点怎么受到数据库变更信息，从而更新其他节点的缓存数据呢？这个是难点，造成使用场景受限。

五、Write Back（写回）策略
感觉这个场景还不是很成熟，所以暂时不研究了。
