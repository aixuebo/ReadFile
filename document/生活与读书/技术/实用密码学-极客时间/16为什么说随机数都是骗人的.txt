一、背景与总结
1.随机数如何生产
使用单向散列函数实现非阻塞的随机数发生器 = 单向散列函数(私密数据+序号)

二、随机数定义
1.不存在真的随机数
第一个问题就是，随机数真的存在吗？
计算机之所以存在，就是因为它的确定性。同一台计算机，相同的数据输入，一定要产生相同的结果。两台不同的计算机，相同的数据输入，也一定要产生相同的结果。
这是计算机存在的基础。怎么会有随机的数据和计算结果呢？所以说，在计算机的世界里，随机数的确是不存在的。
冯·诺伊曼：任何考虑使用数学产生随机数的方法都是不合理的。

其实，我们能够创造出来的，都不是真的随机数。这些所谓的随机数，要么是骗机器的，要么是骗人的，或者两者都骗。严格一点，我们把它们叫做伪随机数。


2.随机数定义(伪随机数)
即便我们知道了随机数产生的机制，以及所有的已经产生的随机数，我们也无法预测下一个随机数是什么。这就是随机数的第一个特点：不可预测。

那怎么检查未来的那个数是随机的呢？产生很多随机数，然后检测这些随机数能不能通过所有的随机性统计检验。

三、随机数怎么产生的
1.产生随机数的诀窍，就是把“相同的数据输入”拆成两部分。一部分是私密的数据，一部分是公开的数据。如果我们能保护住私密的数据，不让人知道，也不让机器拷贝，
那么下一个数据是什么，对于别人或者别的机器来说，可能就是无法预测的。

因此私密数据的质量和计算输出的算法，就决定了随机数的质量。

随机数的应用，我们还需要注意两点：
a.随机数的产生可能会阻塞；
b.随机数的强度要匹配。


2.阻塞的随机数有什么麻烦？
随机数也是有质量要求的，为了保证随机数的质量，随机数发生器的设计需要收集随机信息，比如计算机的噪音，周围的温度，CPU的状态，硬盘的状态，用户的行为等等。

这些信息收集，是需要时间的，所以有的时候，产生下一个随机数的时候，就会阻塞。而对于一个高吞吐量的系统，微秒级别的阻塞可能都是不能忍受的。

应用程序的停顿，会使得占有的资源不能及时地释放，降低系统的效率，增加用户等待时间。

更要命的是，随机数阻塞的时间不确定，有时候时间长到无法忍受，有时候短到毫无影响。除了影响系统的效率和吞吐量之外，还会影响用户体验的一致性，影响程序运行的一致性，也使得出现的问题难以排查。
所以，除非万不得已，我们尽量不要使用阻塞的随机数发生器。

3.非阻塞的随机数还能随机吗？
非阻塞的随机数发生器就不需要收集随机信息了吗？不是的，非阻塞的随机数发生器也需要收集随机信息。区别在于随机信息怎么使用，以及使用的频率。

阻塞的随机数发生器的每一个随机数，都要损耗随机信息；
而非阻塞的随机数发生器，可能仅仅在开始的时候就损耗随机信息（比如说一台计算机开机的时候），然后，随机数的发生就不再损耗随机信息了。只要不再损耗随机信息，就不会有收集随机信息带来的阻塞了。

4.不再损耗随机信息，还能保证随机数的随机性吗？
产生随机数的诀窍，就是持有一部分私密的数据。随机数发生器持有私密的数据，所以计算结果对它来说，是确定的。
如果我们不知道私密的数据，从随机数发生器外面看起来，下一个随机数还是能够做到貌似不可预测的。

四、非阻塞的随机数的实现
1.使用单向散列函数实现非阻塞的随机数发生器 = 单向散列函数(私密数据+序号)
2.为什么该方案是可行的
因为单向散列函数确保了任意序号的变更，都会让结果完全不一致，因此是不可预测的。
单向散列函数运算结果均匀分布，构造碰撞困难。随机数随机分布均匀。
单向散列函数逆向运算困难，因此保存好"私密数据",就可以保证好安全性，随机值被破解的难度大。


五、随机数的安全强度
1.阻塞的随机数发生器
随机数每一位损耗的都是计算机收集的随机信息。随机数的位数也就是它的安全强度。所以，通常的，我们不担心它的安全强度。
即随机数的私密部分是环境收集的，本身就是随机的。

2.非阻塞的随机数发生器
a.受单向散列函数本身的安全强度限制。
b.单向散列函数的输出长度是固定的，而随机数的长度可能并不匹配散列值的长度。SHA-256的散列值长度是256位，如果要产生一个512位的随机数，就需要至少两个散列值的拼接。
由于SHA-256的随机数发生器，它的安全强度不会超过128位，无论这个随机数是256位还是512位。

