一、背景与总结


二、有哪些可用的算法？
1.退役的算法:退役的算法，就是那些已经退出了历史舞台的算法，它们的安全强度很弱，你一定不能再用了。
MD2、MD5、SHA-0、
2.遗留的算法:它们存在明显的安全问题，已经不足以支撑现在的安全强度需求了，你一定不要用在新系统中了。因为，遗留的算法，已经走在退役的路上了。
SHA-1、SHA-224、SHA3-224
3.现行的算法:暂时没有明显的安全问题，是我们现在可以使用的算法。
SHA-256、SHA-384、SHA-512、SHA3-256、SHA3-384、SHA3-512、shake128、shake256

三、每一种算法是有数据量要求的，为什么有处理能力限制？
比如，SHA-256能够处理的最大数据是2^64位。
我们前面说过，单向散列函数可以把任意大小的数据，转行成固定长度的数据。
那为什么有的单向散列函数还有处理能力限制呢？上限不应该是无限大吗？为什么有的单向散列函数，比如SHAKE128，又没有处理能力限制呢？

1.单向散列函数是如何处理输入数据的?
一个典型的单向散列函数，由四个部分组成：数据分组、链接模式、单向压缩函数和终结函数。

数据 --- 分组 -- 压缩函数处理每一个分组 -- 最终输出终结函数 --- 对终结函数处理生成散列值。
a.输入数据任意长度，我们会对其分组。每一组数据位数是固定的。比如SHA-256的压缩函数只能处理512位的数据。
b.数据长度不足分组整数倍时，最后一块要"补齐"。
c.将每一分组的数据进行“压缩函数”处理。

2.问题出现在“补齐”方案。
即补齐的策略是参考输入数据的长度。
SHA-1和SHA-2的数据补齐方案里，输入数据长度是补充数据的一部分。
其中，SHA-1、SHA-224、SHA-256使用64位来表示输入数据长度；
SHA-384、SHA-512、 SHA-512/224和 SHA-512/256使用128位来表示输入数据长度。

因此如果输入数据长度超过了数据补齐方案的限制，数据就没有办法分组了。这就是单向散列函数数据处理能力限制的来源。
而我们说，SHA-3的设计，放弃了在数据补齐方案里使用固定位数表示输入数据长度的做法，它也就不再有数据处理能力的限制。

3.为什么补齐方案这么重要
选择什么样的数据补齐方案，是密码学里一个棘手的问题。很多针对密码算法的攻击，都是从数据补齐方案下手的。
之后，我们会详细讨论单向散列函数的一个常见的算法错配问题：长度延展攻击。

四、算法的性能是怎么决定的？
1.在一个算法的实现细节中，通常影响计算性能的因素有：
算法实现的内存使用影响；
算法实现有没有使用优化的步骤，比如并行计算或者预运算？
算法实现有没有使用硬件加速，比如使用CPU关于算法的扩展指令？

2.一个规规矩矩的算法实现，它的性能一般落后于CPU扩展指令数十倍。遗憾的是，并不是每一个算法都有CPU扩展指令，或者每一个实现都支持CPU扩展指令。

3.计算机本身的指令集，比如是使用32位还是64位的指令，是否和算法匹配，也是影响算法性能的一个重要因素。
我们经常可以看到，SHA-512的计算速度，比SHA-256还要快。SHA-256使用32位的数据进行计算，而SHA-512使用64位的数据进行计算。
现在的计算机，一般都是64位的。所以运行在64位的计算机上，基于32位的计算可能反而比基于64位的计算还要慢。

4.这对我们选用算法有什么启示呢？
一个应用程序，一般而言，应该选用现行的、流行的算法。
现行推荐的算法，保证了算法的安全性。
流行的算法，成熟的实现会考虑实现优化，包括CPU扩展指令的支持。选用流行的算法，也是获得较好计算性能的一个实践办法。

5.对于单向散列函数，目前现行的、流行的算法有：
SHA-256
SHA-384
SHA-512