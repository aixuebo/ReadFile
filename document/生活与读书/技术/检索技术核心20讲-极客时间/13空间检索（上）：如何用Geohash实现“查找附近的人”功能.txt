一、背景与总结
1.如何实现附近查找餐厅、拼车、查找附近好友的功能。
将自己与所有人/车/餐厅的距离做对比，找到最近的N个，在数据规模小的时候，可以这样做；但规模大了,肯定计算量大，是不可以完成的。

2.参考图1、图2、图3

二、使用非精准检索的思路实现“查找附近的人”
1.非精准的找到topK个结果，进一步在K个结果里精准排序找人。
2.非精准查找逻辑
比如找人，在同城找就可以了，没必要全国去找。甚至小区范围内找就可以了。
3.实现思路
a.我们将地图虽然是3维空间，但可以放到2维空间上，他就是一个平面，对平面划分N个区域，每一个区域做一个编号。
b.区域编码作为索引,而区域内的人/车/餐厅，作为检索的对象集合。
c.因为区域有索引，所以很快定位到非精准查找的对象集合，从而可以快速检索到非精准集合。
d.对集合对象，计算自己与每一个人的距离，实现精准排序。

三、核心要解决的问题是如何划分区间 以及 编码
1.平面上使用二分法，水平、垂直各画一条线，就将其分成4份。
左边0，右边1；下边0，上边1
01  11
00  10

2.继续划分，每一个空间还可以划分4个区域。编码方式也相同规则，以此类推，最终划分成N个子区域，每一个子区域有自己的编码。
具体划分到什么粒度，就取决于应用对于“附近”的定义和需求了。

参考图1

3.这种区域编码的方式有2个优点：
区域有层次关系：如果两个区域的前缀是相同的，说明它们属于同一个大区域；
区域编码带有分割意义：从右边开始计位数，奇数位的编号代表了垂直切分，偶数位的编号代表了水平切分。

四、如何快速查询同个区域的人？
1.对区域编码排序，并且保存到数组或者B+树中作索引，这样利用二分查找，很快可以定位到区域。
这样一来，当我们想要查询附近的人时，只需要根据自己的坐标，计算出自己所属区域的编码，然后在索引中查询出所有属于该区域的用户，计算这些用户和自己的距离，最后排序展现即可。

2.这种非精准检索的方案，会带来一定的误差。
因为他忽略了邻居区域，可能离自己更近。
比如说，你的位置正好处于一个区域的边缘，那离你最近的人，也可能是在你的邻接区域里。

3.如何更精准的找人。
a.扩大查找范围,不仅查询自己的区域，还要查询包围自己区域的8个区域。
代价就是计算量提高了8倍。
b.如果要降低计算量，我们可以将区域划分的粒度提高一个量级。
即原来区域划分是300米，现在细到10米，那8倍查找范围也不过多了80米。

4.如何找到相邻编码区域
前面我们说了，区域编码可以根据奇偶位拆成水平编码和垂直编码这两块，如果一个区域编码是0110，那它的水平编码就是01，垂直编码就是10。
因此8个相邻区域,通过区域的加1减1即可查找。
参考图2.

五、什么是Geohash编码？
1.现实中，我们知道经纬度信息，而地球看成一个平面，则经度纬度就是一个切分方式。
给出经纬度后，经纬度各切一刀，则分成4分，因此就有了两位编码。每次切都增加2位编码。
根据最终精准度粒度，可以明确多少位编码表示一块区域。

比如经度切分后11010 01011 01011，维度切分后 10111 00011 01110 。
如果经度和纬度各二分15次的话，那我们就需要30个比特位来表示一个位置的编码。比如 11100 11101 00100 01111 00110 11110。

细粒度参考图3

2.这也就解释了，为什么geohash编码是经纬度穿插的在编码的原因。
原因就是经纬度分别表示 水平切和垂直切。

3.30位的编码太长，不容易阅读，在bit数量不变的情况下，以5个比特位为一个单位，把长编码转为base32编码，最终得到的就是wx4g6y。
原因就是2^5=32,因此可以用32个不同的字符，表示5个bit。所以可以bit存储不变的情况下，更便捷的阅读。
这样30个比特位，我们只需要用6个字符就可以表示了。
这样做不仅存储会更简单，而且具有相同前缀的区域属于同一个大区域，看起来也非常直观。

4.Geohash编码缺点
由于Geohash编码的一个字符就代表了5个比特位，因此每当字符长度变化一个单位，区域的覆盖度变化跨度就是32倍（2^5），这会导致区域范围划分不够精细。
因此，当发现粒度划分不符合自己应用的需求时，我们其实可以将Geohash编码转换回二进制编码的表示方式。
这样，编码长度变化的单位就是1个比特位了，区域覆盖度变化跨度就是2倍，我们就可以更灵活地调整自己期望的区域覆盖度了。



