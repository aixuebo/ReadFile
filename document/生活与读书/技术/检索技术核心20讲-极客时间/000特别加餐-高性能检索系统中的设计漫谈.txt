一、背景与总结
1.重要的设计思想总结
索引与数据分离、减少磁盘IO、读写分离和分层处理

二、索引与数据分离 -- 解耦的设计思想，聚焦在索引的查询效率上，尽可能的在内存中存放更多索引数据。
1.比如B+树中区分中间节点和叶子节点的设计。
总结来说就是，索引与数据分离的设计理念可以让索引保持简洁和高效，来帮助我们聚焦在索引的优化技术上。因此，保持索引的简洁高效是我们需要重点关注的。
而一旦我们忽视了索引中存放数据的影响，那随着系统的变化，索引中掺杂的数据越来越多、越来越复杂，系统的检索性能就会慢慢下降

2.索引和数据分离也会带来一些弊端，如不一致性。
a.对于不要求强一致性的应用场景，比如说在某些应用中更新用户头像时，我们可以接受这种临时性错误，只要能保证系统的最终一致性即可。
b.如果在要求强一致性的应用场景中，比如说在金融系统中。我们可以对索引和数据进行统一加锁处理，或者直接将索引和数据合并。
以MySQL中的B+树为例，来看看它是怎么管理一致性的。
MySQL中的B+树实现其实有两种，一种是MyISAM引擎，另一种是InnoDB引擎。它们的核心区别就在于，数据和索引是否是分离的。
第一，在MyISAM引擎中，数据与索引分离，叶子节点存储的是数据的文件的位置引用。
B+树的叶子节点仅存储了数据的位置指针，这是一种索引和数据分离的设计方案，叫作非聚集索引。
如果要保证MyISAM的数据一致性，那我们需要在表级别上进行加锁处理。

第二，在InnoDB中，数据与索引在一起存储，数据就存储在索引的叶子节点里。
B+树的叶子节点直接存储了具体数据，这是一种索引和数据一体的方案。叫作聚集索引。
由于数据直接就存在索引的叶子节点中，因此InnoDB不需要给全表加锁来保证一致性，它只需要支持行级的锁就可以了。

三、减少磁盘IO,是保证检索系统高效的核心设计思路
1.减少磁盘IO的一种常见设计，是将频繁读取的数据加载到内存中。
2.如果数据量太大，无法都放到内存，则使用B+树、跳表、前缀树、布隆过滤器等数据结构，将索引数据加载到内存里。
3.如果不可避免要读取磁盘，则尽量避免随机读，要使用顺序读。
比如，我们熟悉的基于LSM树的Hbase和Kafka、levelDB，就都采用了类似的设计。

4.如果换用SSD磁盘，还要关注减少磁盘IO的设计吗？
还是要关注的，第一性价比上，如果关注减少磁盘IO，使用SSD会更高效。
第二，从SSD原理上，
对于SSD而言，它以页（Page，一个Page为4K-16K）为读写单位，以块（Block，256个Page为一个Block）为垃圾回收单位。
由于SSD不支持原地更新的方式修改一个页，因此当我们写数据到页中时，SSD需要将原有的页标记为失效，并将原来该页的数据和新写入的数据一起，写入到一个新的页中。
那被标记为无效的页，会被垃圾回收机制处理，而垃圾回收又是一个很慢的操作过程。
因此，随机写会造成大量的垃圾块，从而导致系统性能下降。
所以，对于SSD而言，批量顺序写的性能依然会大幅高于随机写。

四、读写分离 --- 高并发场景，避免使用锁解决问题
在高并发的场景下，如果系统需要对同一份数据同时进行读和写的操作，为了保证线程安全以及数据一致性，我们往往需要对数据操作加锁，但这会导致系统的性能降低。

读写分离的场景
MySQL和Redis这类的数据存储系统的Master - Slave设计。
在倒排索引类的检索系统中，索引更新机制 Double Buffer机制。以及全量索引+增量索引的机制来实现读写分离。
levelDB写入内存数据，然后写满后，原子操作切换成不可写的内存对象，同时创建新的可写入的对象进行接受新数据。
以上都避免了使用锁的场景，解决了高并发的性能问题。

五、分层处理
1.分层案例
a.典型的例子，非精准Top K检索 + 精准 Top K检索的设计思路了。
如果我们对所有的检索结果集都进行耗时复杂的精准打分，那会带来大量的资源浪费。所以，我们会先进行初步筛选，快速选出可能比较好的结果，再进行精准筛选。
b.我们前面提到的将索引放在内存中而不是磁盘上，这其实也是一种分层处理的思路。我们对索引进行分层，把最有价值的索引放在内存中，保证检索效率。
c.LSM树将它认为最有价值的近期数据放在内存中，然后将其他数据放在磁盘上的思路是非常相似的。
d.CPU中的一级缓存和二级缓存，将最有价值的数据，存在离CPU最近，也最贵的介质中。
e.为了保证系统的稳定性，我们往往需要在系统负载过高时，启用自动降级机制。
好的自动降级机制，其实也是对流量进行分层处理，将系统认为有价值的流量保留，然后抛弃低价值的流量。

