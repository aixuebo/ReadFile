一、背景与总结
1.应用场景
在注册新用户时，我们需要先快速判断这个用户ID是否被注册过。
在爬虫系统抓取网页之前，我们要判断一个URL是否已经被抓取过
2.算法复杂度 O(1) + O(1) 

二、Bitmap -- 位图
1.数组,一个bit表示状态是否存在。

2.但系统里并没有以bit为单位的数据类型，因此，我们往往需要对其他类型的数组进行一些转换设计，使其能对相应的bit位的位置进行访问，从而实现位图。

以char类型的数组为例子。假设我们申请了一个1000个元素的char类型数组，每个char元素有8个bit，如果一个bit表示一个用户，那么就能表示8*1000 = 8000个用户。
如果一个用户的ID是11，那么位图中的第11个bit就表示这个用户是否存在的信息。

3.这种情况下，我们怎么才能快速访问到第11个bit呢？
一个元素占8个bit，我们用11除以8，得到的结果是1，余数是3。
这就代表着，第11个bit存在于第2个元素里，并且在第2个元素里的位置是第3个。

对于第2个元素的访问，我们直接使用数组下标[1]就可以在O(1)的时间内访问到。
对于第2个元素中的第3个bit的访问，我们可以通过位运算，先构造一个二进制为00100000的字节（字节的第3位为1），然后和第2个元素做and运算，就能得知该元素的第3位是1还是0。这也是一个时间代价为O(1)的操作。

这样一来，通过两次O(1)时间代价的查找，我们就可以知道第11个bit的值是0还是1了。


三、进一步优化空间
1.现在一个用户已经可以使用一个bit表示了，因此已经最优了。
2.数组长度是否可以优化呢？
因为数组长度必须大于ID的上限。因此数组长度受最大的ID限制。数组可能最终是稀疏的。
因此我们可以用hash+mod的方式，减少稀疏性。
3.如果key字符串，而不是整数，使用hash+mod方式也可以平滑对接。

四、上一个过程中，产生的问题
我们也知道，数组压缩得越小，发生哈希冲突的可能性就会越大，如果两个元素A和B的哈希值冲突了，映射到了同一个位置。那么，如果我们查询A时，该位置的结果为1，其实并不能说明元素A一定存在。
因此，如何在数组压缩的情况下缓解哈希冲突，保证一定的查询正确率，是我们面临的主要问题。

解决方案:布隆过滤器（Bloom Filter）的设计思想
使用多个hash函数，来将数据转换成多个bit位，降低冲突的概率。我们不再使用一位来表示一个对象，而是使用k位来表示一个对象。这样两个对象的k位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。
即所有的bit位都是1，才有可能状态存在。
有任意bit位不是1，说明一定不存在。


我们的使用场景：我们希望用更小的代价快速判断ID是否已经被注册了。
在这个使用场景中，就算我们无法确认ID是否已经被注册了，让用户再换一个ID注册，这也不会损害新用户的体验。
在系统不要求结果100%准确的情况下，我们可以直接当作这个用户ID已经被注册了就可以了。这样，我们使用布隆过滤器就可以快速完成“是否存在”的检索。


除此之外，对于布隆过滤器而言，如果哈希函数的个数不合理，比如哈希函数特别多，布隆过滤器的错误率就会变大。--- 因为函数越多，说明被设置1的位置越多。
因此，除了使用多个哈希函数避免哈希冲突以外，我们还要控制布隆过滤器中哈希函数的个数。有这样一个计算最优哈希函数个数的数学公式: 哈希函数个数k = (m/n) * ln(2)。
其中m为bit数组长度，n为要存入的对象的个数。实际上，如果哈希函数个数为1，且数组长度足够，布隆过滤器就可以退化成一个位图。所以，我们可以认为“位图是只有一个特殊的哈希函数，且没有被压缩长度的布隆过滤器”。