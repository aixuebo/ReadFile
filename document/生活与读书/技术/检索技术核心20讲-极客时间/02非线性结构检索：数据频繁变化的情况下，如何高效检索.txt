一、背景与总结
1.非线性的结构，可以提供性能较高的查询。
比如生活中的电脑文件夹管理树层次结构。

2.频繁更新的场景下，连续存储的有序数组，由于更新频繁，需要不停地排序移动，检索性能也会下降，因此也不适合频繁更新场景使用数组存储数据。

3.目标是将数组与链表做整合，非线性的树状结构来改造有序链表，这样有了链表的插入/删除高性能能力，也有了二分查找的能力。

二、树结构是如何进行二分查找的？
1.二叉树 --- O(log n)
左next + 数据 + 右next。
因为链表持有左右两个next，因此可以做到二分排序。困难点是如何构造二叉树，即数据是有顺序排列好的。

2.平衡二叉树 或者 红黑树，目标都是将二叉树转换成平衡的。

三、跳表是如何进行二分查找的？ -- Skip List
1.背景
我们知道，链表之所以访问中间节点的效率低，就是因为每个节点只存储了下一个节点的指针，要沿着这个指针遍历每个后续节点才能到达中间节点。
那如果我们在节点上增加一个指针，指向更远的节点，比如说跳过后一个节点，直接指向后面第二个节点，那么沿着这个指针遍历，是不是遍历速度就翻倍了呢？
同理，如果我们能增加更多的指针，提供不同步长的遍历能力，比如一次跳过4个节点，甚至一半的节点，那我们是不是就可以更快速地访问到中间节点了呢？

2.理想的跳表
一个理想的跳表，就是从链表头开始，用多个不同的步长，每隔2^n个节点做一次直接链接（n取值为0，1，2……）。
跳表中的每个节点都拥有多个不同步长的指针，我们可以在每个节点里，用一个数组next来记录这些指针。next数组的大小就是这个节点的层数，
next[0]就是第0层的步长为1的指针，next[1]就是第1层的步长为2的指针，next[2]就是第2层的步长为4的指针，依此类推。

即每一个数据，都有一个next数组，分别指向更远的数据。

3.举个例子
假设 a1  a2 。。。。 a100 数据按照顺序存储。
a1下有一个数组next。

当我们要检索k=a6时，从第一个节点a1开始，用最大步长的指针开始遍历，直接就可以访问到中间节点a5。
此时在a5上用最大的步长遍历，下一个节点是a9，这说明k在a5和a9之间。
用小一个级别的步长继续查询。这时候，a5的下一个元素是a7，a7依然大于k的值，
因此，我们会继续在a5和a7之间，用再小一个级别的步长查找，这样就找到a6了。这个过程其实就是二分查找。时间代价是O(log n)。

4.跳表的检索空间平衡方案
为什么我们前面要叫他 理想的 调表呢。
当我们要在跳表中插入元素时，节点之间的间隔距离就被改变了。如果要保证理想链表的每隔2^n个节点做一次链接的特性，我们就需要重新修改许多节点的后续指针，这会带来很大的开销。
所以，在实际情况下，我们会在检索性能和修改指针代价之间做一个权衡。
因此，当新节点插入时，我们不去修改已有的全部指针，而是仅针对新加入的节点为它建立相应的各级别的跳表指针。具体的操作过程，我们一起来看看。

首先，我们需要确认新加入的节点需要具有几层的指针。我们通过随机函数来生成层数，比如说，我们可以写一个函数RandomLevel()，以(1/2)^n的概率决定是否生成第n层。
这样，通过简单的随机生成指针层数的方式，我们就可以保证指针的分布，在大概率上是平衡的。

在确认了新节点的层数n以后，接下来，我们需要将新节点和前后的节点连接起来，也就是为每一层的指针建立前后连接关系。其实每一层的指针链接，你都可以看作是一个独立的单链表的修改，
因此我们只需要用单链表插入节点的方式完成指针连接即可。

