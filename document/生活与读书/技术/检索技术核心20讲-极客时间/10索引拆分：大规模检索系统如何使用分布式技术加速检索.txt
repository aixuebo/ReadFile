一、背景与总结
1.前两节课，分别讲了如何使用map-reduce的方式构建索引；以及如何更新索引信息；
但都没有讲解如何优化读取索引。本节课主要讲述这个内容。

2.索引分片
指代的是分布式环境下，每一个服务器只计算一部分文档的索引，因此每一个服务器上的索引是整体索引的一个子集，因此称之为索引分片。
实际查询时,是将所有服务器节点查询的索引分片做merge，然后返回给客户端。

相当于 partition by(文档ID % 分片数量)

二、简单的分布式检索结构
1.步骤
a.用户请求到“分发服务器”,分发服务器把请求分发到"检索服务器"去执行。
b.任意一个检索服务器，都是同样的作用，都能完成检索工作。
即所有服务器都有相同的全量索引信息。(其实这个索引信息如何同步到所有节点的，也应该讨论一下，下面的优化方案就是这种分布式查询方案)

比如一台机器可以一秒处理1000个请求，现在10台检索服务器，则每秒可以处理1万个请求。
问题是这种分布式检索结构只是增加了吞吐量，而不能缩短每一个请求的检索时间，即单机需要1秒检索一条数据，现在依然需要1秒检索一条数据。


三、如何能提升检索效率呢
本质上，检索是在磁盘上做检索的，如果都能在内存检索，一定是查询快的。
怎么能放内存里检索呢，即把全量索引拆分，按某些规则，分布在不同的节点上，存储的内容是不同的。而且每一个节点的数据是可以放到内存里的。这样就会快了。

1.基于业务规则的拆分，举例
图书馆的书，按照国内、国外索引，分别存储在不同的机器上，查询国内的书，只需要请求国内索引服务器即可。

2.通用拆分逻辑，基于文档拆分，举例
	即每一个服务器节点，存储一部分文档，针对部分文档创建索引。
	请求不是分发到某一个节点就可以获取全量信息，而是需要分发到全部节点，获取每一个节点的结果，然后分发服务器做结果merge。
	
	每一个服务器上的倒排索引，称之为 索引分片。
	每一个服务器管理不同的索引分片。
	因为每一个服务器的文档id不是全量文档id，因此posting list都不会太长，可以放到内存里，这样单机的检索效率也就得到了提升。

	检索步骤
	我们的检索流程可以总结为3个步骤：
	a.分发服务器接受查询请求，将请求发送给所有不同索引分片的索引服务器；
	b.每台索引服务器根据自己加载的索引分片进行检索，将查询结果返回分发服务器；
	c.分发服务器将所有返回的结果进行合并处理，再返回最终结果。

	注意事项
	分片的数量也不宜过多。
	a.如果分片过多的话，每台加载索引分片的服务器都要返回n个检索结果，这会带来成倍的网络传输开销。
	b.分片越多，分发服务器需要合并的工作量也会越大，这会使得分发服务器成为瓶颈，造成性能下降。
	c.每一个分片还要做副本，可以增加吞吐量。

3.基于词典term的拆分
好处是，相同的term词的文档一定在同一个服务器，避免了查询多个服务器做merge的操作。
缺点:是管理成本高，
a.如果查询多个词，没有被分配到同一个服务器，还是需要再分发服务器做merge；
b.如果有的关键词是高频词，那么对应的文档列表会非常长，检索性能也会急剧下降。
c.还有新增文档的索引修改问题，系统热点查询负载均衡的问题等。

因此，除了少数的高性能检索场景有需求以外，一般我们还是基于文档进行索引拆分。这样，系统的扩展性和可运维性都会更好。

