一、背景与总结
1.显示中遇到的问题
a.数据量大，不可能都存放在内存里。
b.查询磁盘效率慢，所以数据放在磁盘上，无法达到检索效率，所以需要一种特殊的数据结构去做磁盘检索。

2.今天我们就一起来聊一聊磁盘上的数据检索有什么特点，以及为什么B+树能对磁盘上的大规模数据进行高效索引。
二叉树，可以支持频繁的新增/删除节点、范围查找、二分法获取数据，因此更适合检索需求。

3.B+树
B+树给出了将树形索引的所有节点都存在磁盘上的高效检索方案，使得索引技术摆脱了内存空间的限制，得到了广泛的应用。

其实也是二叉树的升级版，是N叉树，主要减少了树的深度，更减少了磁盘扫描次数，效率更高。
二叉树的支持频繁的新增/删除节点、范围查找功能也都保留,毕竟这些功能属于树的基础能力。

4.一个节点存储多少个元素的计算方式
a.因为一个数据块读取受磁盘影响，正常一个数据快读取是4k。
b.索引字段明确后，每一个索引占用存储是知道的，比如占用10个字节。
c.因此明确一个B+树节点，需要存储400个节点，即400个节点后，就站满了一个树节点 400 * 10字节 = 4k。
d.因此4层树，可以存储 400^4 = 256亿个元素。

5.总结
a.内存存储不了非常大的数据，所以想存储到磁盘上。
b.把树结构存储到磁盘上，那么多少层的树，每次查询就需要扫描多少次磁盘。
c.磁盘检索效率慢，优化方案是减少磁盘扫描次数，因此减少树层数，因此改造二叉树，改成M叉树。
即每一个节点不在存储两个元素，而是存储M个元素的地址。
d.M越大，每一层的存储的数据越多，肯定层数越少。那么M定多少合适呢？
涉及到磁盘的读取原理，每次磁盘读取一个数据块，大概是4k,因此一个树节点存储4k最好。
而索引字段确定后，其实是知道一个数据占用空间的，因此反推出一个树节点存储多少个数据。从而明确了M大小。
e.树结构的同一层，节点之间是有顺序的。
因此节点内是有顺序的存储一个有序集合，而节点间使用双向链表，存储同一层下一个节点的引用地址。
因此天然支持范围查找。
f.利用内存，将前3层缓存在内存中，更进一步减少了读取磁盘的次数。


二、磁盘和内存读取数据的方式特点
1.内存是半导体元件，因此给出内存地址，就可以直接访问到，并且读取、存储信息。
因此是非常高效的可以进行随机访问。因此内存也叫随机访问存储器（Random Access Memory，即RAM）。

2.磁盘是机械器件。
访问数据,需要磁盘旋转到磁头，才能读取数据。因此随机读取/存储，效率很慢，需要磁头旋转到位置后才能操作。
但是因为磁盘旋转非常快，即转速快，因此如果顺序读/顺序写，效率是非常高的，基本上与内存性能是同一个数量级别的。
因此在数据结构上需要设计，应对磁盘存储数据可以高效读取。


磁盘的最小读写单位是扇区(以前一个扇区存储512字节,现在是4k)。
操作系统一次读取的单位是块（Block），也叫作簇（Cluster）。即一次会读写多个扇区。
因此就算我们从磁盘读取的内容是非常小的内容，也需要一次性把整个Block读取出来。


3.如果有序数组存储在磁盘里，找数据需要读取几次磁盘？
因此采用二分法查找，每次都要读取一次磁盘。因此最终取决于二分法读取的次数。即树的深度。
因此这样的检索性能非常低。

4.如何优化磁盘检索效率呢
答案显而易见，就是减少磁盘读取次数即可。

三、数据与索引分离，减少磁盘读取次数。 ---- 二叉树
1.举例
比如要读取用户信息，但用户信息存储了很多内容，如果没有索引，假设用户一个信息包含1k,那么数据即是有顺序，也是需要多次扫描磁盘的。
而我们知道一个用户id也就8个字节的long,将其单独存储，找到目标后在一次性的读取磁盘，肯定效率会更高。

ID+data+ID+data....  ----> ID+磁盘位置+ID+磁盘位置+... 即一个用户只有一个long+long组成。因此优先的空间内可以存储非常多的有序ID集合，
方便二分查找，减少读取磁盘的次数，只需要最后读取一次磁盘即可。

2.既然是有序的ID集合，那用什么数据结构存储该集合 更适合快速检索呢?
因为ID频繁插入/删除，因此有序数组不是一个好的选择，因为每次数组都要移动，复杂度高。
哈希表虽然可以支持插入/删除/读取都性能高，但他不能支持范围查询。
二叉树支持快速插入/删除/范围查询，并且有序的二叉树又支持二分查找，从根节点可以顺序查找，因此更适合。

即 一个二叉树节点内容如下:  left节点+ID+磁盘位置+right节点

四、如何理解B+树的数据结构？
1.原理
a.二叉树 升级为 M叉树，这样树的层级会更低，更减少的磁盘的扫描。
操作系统对磁盘数据的访问是以块为单位的。所以如果二叉树每一个节点的内容，整好是一个数据块,那读取、存储效率是最高的。
而二叉树很明显只有ID和磁盘位置，不会包含那么多字节的数据，因此需要改造，将其改造成m叉树，每一个节点存储m个有序的数组。

b.节点分为 内部节点和叶子节点，数据结构是一样的，只是内部节点只存储索引+树指针，叶子节点存储具体的数据(具体的数据或者文件的位置)。
因此内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。

因此内部节点存储为ID+指针+ID+指针+ID+指针。。。 叶子节点存储 ID+数据内容/文件位置。

c.二叉树和M叉树都共同优点，每一层是可以二分查找/M分查找，因此说明同一层的数据是有顺序的。
因此B+树还将同一层的所有节点串成了有序的双向链表，B+树就同时具备了良好的范围查询能力和灵活调整的能力了。

d.B+树是一棵完全平衡的m阶多叉树。所谓的m阶，指的是每个节点最多有m个子节点，并且每个节点里都存了一个紧凑的可包含m个元素的数组。

2.读取数据原理
内部节点，找到叶子节点位置:  通过树的结构，一层一层往下找，找到任意一层数据块后，读取一个节点的数据块内容，因为包含了M个数组，所以很容易读取到下一层的指针。
叶子节点，如果是get(id),可以很快找到文件位置，就读取信息。
叶子节点,如果是范围查找，则读取一个数据块后，相当于读取了多条数据，是磁盘的顺序读，效率高。
如果一个数据块读取完成后，读取下一个数据块即可，因为同一个层级上，数据块之间是有顺序的，并且是双向链表，是可以知道下一个数据块的磁盘位置的。


3.基于2的原理，我们看一下B+树的检索
a.每一层都需要读取一次磁盘。因此需要N次读取磁盘。
b.因为每一层都是M个元素，因此第1层有M个数据，第2层有M^M数据，因此如果是4层，则数据存储的体量就非常大了。即M^4次方。
因为当索引字段确定后，而索引字段多半不是string类型，而是int类型(因为string类型无法预测索引大小，所以索引效率肯定不好，因此不建议string做索引)。


因为一个数据块读取受磁盘影响，正常一个数据快读取是4k。
索引字段明确后，每一个索引占用存储是知道的，比如占用10个字节。
因此明确一个B+树节点，需要存储400个节点，即400个节点后，就站满了一个树节点 400 * 10字节 = 4k。
例如一个索引占用10个字节，而一个数据块是4k，因此可以存储400个元素。
因此4层树，可以存储 400^4 = 256亿个元素。

c.4层，说明要读取4次磁盘，也是可以优化的。
第一层，就存储了400个元素，即4k。
第二层，存储了400个数据块，即400*4k = 1.6M。
第三层，存储了400^2个数据库，即160000个节点，即160000 * 4k = 640M。

因此将前三层存储在内存即可，只扫描一次磁盘就可以获取到数据。

这也是为什么要将数据与索引分开存储的原因，让索引尽量加载到内存里。
如果用户查找的就是索引，则直接返回数据，都不需要查询磁盘检索数据的其他内容了。

五、B+树如何动态调整树的高度 --- B+树在“新增节点”和“删除节点” 怎么操作。
因为B+树要一直保持索引的顺序性，因此插入/删除时，肯定有一些改变树结构的问题，那该如何处理呢。

1.步骤
a.具体的数据肯定都在叶子节点上，因此通过查找，找到叶子节点后，先插入到叶子节点所在的数据块内。
如果数据块本身未满，则直接插入即可。
如果数据块满了,则需要将叶子节点分裂，从中间分裂成两部分，因此每一个部分都可以有空间存储新元素了。找到位置后，存储即可。
而分裂的中间节点，就在上一层找到合适的位置存储即可。
b.上一层位置也会出现a的问题，即满了或者未满，重复操作即可。
最终可能就影响了树的高度。

2.删除操作同理。
a.节点数据块满了,直接删除即可。
b.如果删除后，空间一半都是空的，则为了提高存储效率，将左右两个节点进行merge。
