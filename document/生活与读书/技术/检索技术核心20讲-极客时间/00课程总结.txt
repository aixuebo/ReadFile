一、背景与总结


二、各算法的复杂的
1.数组和链表
数组插入和删除效率慢，但查询效率快。链表反之。
2.二分查找:有序数组、二叉检索树还是跳表  O(log n) 
3.hash检索 理论上是O(1)，其实是O(1) + 二分查找的链表红黑树实现O(log n) 。
4.Bitmap -- 位图，算法复杂度 O(1) + O(1) 
5.倒排索引 -- N个词查询倒排索引O(1) + 索引结果的merge操作O(m + n)
6.二叉树，可以支持频繁的新增/删除节点、范围查找、二分法获取数据，因此更适合检索需求。
7.B+树，其实也是二叉树的升级版，是N叉树，主要减少了树的深度，更减少了磁盘扫描次数，效率更高。
二叉树的支持频繁的新增/删除节点、范围查找功能也都保留,毕竟这些功能属于树的基础能力。
8.LSM树，解决了非随机读，而是日志读取最近的数据问题。
日志系统、监控系统场景，特点是数据量存储非常大，写入频繁，但检索时候只关注最近一段时间内的数据，而不是全范围查询。
频繁写入B+树，会使节点不断分裂，（因为节点内索引是要排序的）
9.全文检索，基于内容或者属性的检索场景，我们可以使用倒排索引完成高效的检索。
存储字典表+posting list。
字典表存储在内存里，映射的是字典对应的posting list在磁盘中的位置信息，读取磁盘中posting list的内容即可。

如果字典表很大，不能放内存里，或者一个term的posting list很大，不能放内存里，则使用B+树的方式，存储字段和posting list。
原因就是字段本身是按照key排序的，而posting list也是按照wordID排序的，因此对于有顺序的都可以使用B+树做检索。
相当于字典term key就是使用mysql存储了索引。

10.搜索引擎精准选择topK --- TF-IDF
原因是倒排索引存储某一个term的文档很大，此时多个查询term对应的倒排索引posting list要做merge，并且排序，要解决的是如何能快速在大的posting list里检索。

11.geohash编码,用于查找附近人。
12.最近邻检索 -- 局部敏感哈希,解决文章的相似性。检索相似文章。
用于搜索引擎中，文章去重。
相同的图片，这种语义识别相似性检索，如何实现？
13.LevelDb基于LSM树，创建的KV检索系统，了解其原理，可以深度阅读文章。
