一、背景与总结
1.本文讨论重点
倒排索引的检索过程中，两个posting list求交集是一个最重要、最耗时的操作，因此是如何借助跳表、哈希表和位图，这些基础数据结构进行加速的。


二、跳表法加速倒排索引
1.demo
假设posting list A中的元素为<1,2,3,4,5,6,7,8……，1000>，这1000个元素是按照从1到1000的顺序递增的。
B中的元素，只有<1,500,1000>3个。

2.正常逻辑 -- 链表遍历，时间代价高
那按照我们之前讲过的归并方法，它们的合并过程就是，在找到相同元素1以后，还需要再遍历498次链表，才能找到第二个相同元素500。

3.加速逻辑
将A和B的链表，改成跳表。
这样，在posting list A中，我们从第2个元素遍历到第500个元素，只需要log(498)次的量级，会比链表快得多。


使用相互二分查找,加速更快。你可以这么理解：
如果A中的当前元素小于B中的当前元素，我们就以B中的当前元素为key，在A中快速往前跳；
如果B中的当前元素小于A中的当前元素，我们就以A中的当前元素为key，在B中快速往前跳。
这样一来，整体的检索效率就提升了。

三、哈希表法加速倒排索引
利用O(1)的特性，当计算两个集合交集时，如果一个集合特别大，另一个集合相对比较小，那我们就可以用哈希表来存储大集合。
这样，我们就可以拿着小集合中的每一个元素去哈希表中对比。

复杂度为N * O(1) = O(N),N表示小集合的元素数量。

因此hash方式优势在很多短posting list存在的前提下，才能更好地发挥作用。这是因为哈希表法的查询代价是O(m)，如果m的值很大，那它的性能就不一定会比跳表法更优了。

四、位图法加速倒排索引
1.如果所有的posting list全部改造为位图，那直接可以用位运算，计算交集。
首先，我们需要为每个key生成同样长度的位图，表示所有的对象空间。
然后，如果一个元素出现在该posting list中，我们就将位图中该元素对应的位置置为1。
查询时，两个位图 进行 & 操作。

2.缺点
a.浪费空间，稀松矩阵，因为每一个关键词都要拥有所有docid的集合。
如果用int表示一个docid集合范围,因此一个key对应的位图就需要512M。 即512M才能存储int的max值范围。
因此有1万个key,需要5120G空间，太大了。
b.位图法仅适用于只存储ID的简单的posting list。如果posting list中需要存储复杂的对象，就不适合用位图来表示posting list了。

五、Roaring Bitmap来代替位图
在很多成熟的工业界系统中，为了解决位图的空间消耗问题，我们经常会使用一种压缩位图的技术Roaring Bitmap来代替位图。

参考
数学/统计算法/bitmap
java基础/集合/bitmap
生活与读书/技术/检索技术核心20讲/05-1-倒排索引


1.将有序数组+位图结合，解决判断是否元素存在的需求场景。可以保证高效检索:
如果我们要确认一个元素是否在Roaring Bitmap中存在，通过两次查找就能确认了。
第一步是以高16位在有序数组中二分查找，看对应的桶是否存在。代价 O（log n）
第二步就是将桶中的位图取出，拿着低16位在位图中查找，判断相应位置是否为1。代价 O(1)。


2.那它到底是怎么节省存储空间的呢？
如果一个posting list中，所有元素的高16位都是相同的，那在有序数组部分，我们只需要一个2个字节的桶
（注：每个桶都是一个short型的整数，因此只有2个字节。如果数组提前分配好了2^16个桶，那就需要128K字节的空间，因此使用可变长数组更节省空间）
在低16位部分，因为位图长度是固定的，都是2^16个bit，那所占空间就是8K个字节。

同样都是32位的整数，这样的空间消耗相比于我们在位图法中计算的512M字节来说，大大地节省了空间！
你会发现，相比于位图法，这种设计方案就是通过，将不存在的桶的位图空间全部省去这样的方式，来节省存储空间的。

3.那每个桶对应的位图空间，我们是否还能优化呢？
如果一个桶中存储的数据少于4096个，我们就不使用位图，而是直接使用short型的有序数组存储数据。
同时，我们使用可变长数组机制，让数组的初始化长度是4，随着元素的增加再逐步调整数组长度，上限是4096。这样一来，存储空间就会低于8K，也就小于使用位图所占用的存储空间了。

4.容器的转换 Bitmap vs Array
第一种，在一个桶中刚插入数据时，因为数据量少，所以我们就默认使用数组容器；
第二种，随着数据插入，桶中的数据不断增多，当数组容器中的元素个数大于4096个时，就从数组容器转为位图容器；
第三种，随着数据的删除，如果位图容器中的元素个数小于4096个，就退化回数组容器。

5.如何求交集
假设，这里有Roaring Bitmap表示的两个集合A和B，那我们求它们交集的过程可以分为2步。
第1步，比较高16位的所有桶，也就是对这两个有序数组求交集，所有相同的桶会被留下来。 ---- 两个有序数组之间的交接运算。
第2步，对相同的桶里面的元素求交集。因为每一个容器对应的类型不同，这个时候会出现3种情况，分别是位图和位图求交集、数组和数组求交集、位图和数组求交集。
即 Bitmap vs Array ，Bitmap vs Bitmap，Array vs Array

其中，位图和位图求交集，我们可以直接使用位运算；
数组和数组求交集，我们可以使用相互二分查找（类似跳表法）；
位图和数组求交集，我们可以通过遍历数组，在位图中查找数组中的每个元素是否存在（类似哈希表法）。

