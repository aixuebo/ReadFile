一、背景与总结
1.背景
大多数OLTP数据库中，存储都是以面向行的方式进行布局的：表格的一行中的所有值都相邻存储。所以每次查询都是把匹配的所有行的所有列信息都从硬盘加载到内存，然后再进行过滤。
列式存储背后的想法很简单：将来自每一列的所有值存储在一起。如果每个列式存储在一个单独的文件中，查询只需要读取和解析查询中使用的那些列，这可以节省大量的工作。

二、位图索引
1.如果数据库表中有特殊识别一行数据的字段，比如身份证，那么此时使用B树会更合适。
但如果字段是性别、婚姻状况(已婚、未婚、离婚)，即列的基数非常小，因此创建一个单独的位图索引会更合适。

2.位图索引的结果
a.每一行使用一个bit代替。
b.有都少个枚举值，就有多少个位图索引。

比如婚姻状态有3个枚举值，用户作为列，一列中只有一个状态是1.

用户1  已婚
用户2  未婚
用户3  离婚

rowid  用户1  用户2  用户3
已婚    1      0     0
未婚    0      1     0
离婚    0      0     1

因此最终针对婚姻状态，创建一个位图索引，结果是3个具体的索引，每一个索引的数组长度都等于所有数据条数，即每一条数据占用一个bit。


3.实现
select *
from biao 
where 婚姻状态 = '离婚' and sex = ‘男’。
此时只要找到离婚的位图索引 & 性别男的位图索引，做与操作，返回的结果中，bit是1的表示命中两个条件的数据，可以进一步进行过滤。

4.位图索引的适用场景:
a.适合几个固定枚举值的列，身份证号码这种不适合。
b.适合静态数据，而不适合索引频繁更新的列。
举个例子，有这样一个字段busy，记录各个机器的繁忙与否，当机器忙碌时，busy为1，当机器不忙碌时，busy为0。
假设用户A使用update更新某个机器的busy值，比如update table set table.busy=1 where rowid=100;，但还没有commit，而用户B也使用update更新另一个机器的busy值，
update table set table.busy=1 where rowid=12; 这个时候用户B怎么也更新不了，需要等待用户A commit。
原因：用户A更新了某个机器的busy值为1，会导致所有busy为1的机器的位图向量发生改变，因此数据库会将busy＝1的所有行锁定，只有commit之后才解锁。

三、列存储特点
1.列压缩
进一步降低硬盘吞吐量。
尤其位图索引会压缩比更高。

2.内存带宽和矢量化处理
a.数仓经常需要扫描几百万行数据用来分析，巨大的瓶颈是从磁盘读取到内存的IO，列存储减少读取的IO，提高了性能。
b.有效利用内存到CPU缓存的带宽，避免 CPU 指令处理流水线中的分支预测错误和闲置等待，以及在现代 CPU 上使用单指令多数据（SIMD）指令来加速运算。
c.列式存储布局也可以有效利用 CPU 周期。例如，查询引擎可以将一整块压缩好的列数据放进 CPU 的 L1 缓存中，然后在紧密的循环（即没有函数调用）中遍历。
相比于每条记录的处理都需要大量函数调用和条件判断的代码，CPU 执行这样一个循环要快得多。列压缩允许列中的更多行被同时放进容量有限的 L1 缓存。
前面描述的按位 “与” 和 “或” 运算符可以被设计为直接在这样的压缩列数据块上操作。这种技术被称为矢量化处理（vectorized processing）。

3.列式存储中的排序顺序
难点是如何进行不同的列，使用相同的排序方式。可能要求每一个列都在内存List里排序，list的元素按照key排序后的位置进行插入。最终将列物化到磁盘。然后小文件在做merge(毕竟每一个文件都已经是有序的)。
a.列存储中，每一行被插入，都是在不同的列文件中进行追加操作。
b.我们也可以考虑按照某一个顺序来对文件进行排序。起到索引作用。
注意:对每列分别执行排序是没有意义的，因为那样就没法知道不同列中的哪些项属于同一行。因此排列的顺序是所有的列都要按照这样的方式排序。
比如按照dt+sku_id进行排序，可以保证同一天同一个商品的数据都集中在一起。此时查询某一个商品的数据就很快可以聚合。即很快可以做分组或者过滤查询操作。
d.排序后列的压缩效果更好。
因为排序的列基本上不会有太多不同的值，即在排序后，将会得到连续重复多次的列，此时压缩比会更大，比如前100条都是dt+同一个sku_id，此时压缩肯定比乱序的dt+sku_id效果会更高。
比如：将该列压缩到几 KB —— 即使表中有数十亿行。
第一个排序键的压缩效果最强。第二和第三个排序键会更混乱，因此不会有这么长的连续的重复值。排序优先级更低的列以几乎随机的顺序出现，所以可能不会被压缩。但对前几列做排序在整体上仍然是有好处的。
e.几个不同的排序顺序
因为用户查询条件是不同的，所以查询排序的结果也会不同，效果会更好。
同时反正数据都需要做备份，以防单点故障时丢失数据。因此你可以用不同排序方式来存储冗余数据，以便在处理查询时，调用最适合查询模式的版本。
结论就是类似doris的rollup,其实就是对数据重新进行排序，单独存储成一个文件。
与面向行的存储将每一行保存在一个地方（在堆文件或聚集索引中），次级索引只包含指向匹配行的指针。在列式存储中，通常在其他地方没有任何指向数据的指针，只有包含值的列。


四、写入列存储
1.如何提高数仓查询效率 -- 毕竟数仓分析都是sql查询海量数据，任何优化都是有意义的
列存储（减少读取的IO）、列压缩(降低存储空间 && 利用内存和CPU计算)、排序(减少扫描数据量)

缺点就是写入操作非常困难，考虑的点很多。

2.写入方案 -- 基于 LSM 树原理
所有的写操作首先进入一个内存中的存储，在这里它们被添加到一个已排序的结构中，并准备写入硬盘。内存中的存储是面向行还是列的并不重要。当已经积累了足够的写入数据时，它们将与硬盘上的列文件合并，并批量写入新文件。这基本上是 Vertica 所做的。

3.查询
检查硬盘上的列数据和内存中的最近写入，并将两者的结果合并起来。

五、聚合：数据立方体和物化视图
1.物化聚合（materialized aggregates）
数据仓库查询通常涉及一个聚合函数，如 SQL 中的 COUNT、SUM、AVG、MIN 或 MAX。如果相同的聚合被许多不同的查询使用，那么每次都通过原始数据来处理可能太浪费了。为什么不将一些查询使用最频繁的计数或总和缓存起来？

2.创建这种缓存的一种方式是物化视图（Materialized View）
不同的是，物化视图是查询结果的实际副本，会被写入硬盘，而虚拟视图只是编写查询的一个捷径。从虚拟视图读取时，SQL 引擎会将其展开到视图的底层查询中，然后再处理展开的查询。

3.优缺点
优点:
某些查询变得非常快，因为它们已经被有效地预先计算了。即仅存储维度+指标的聚合结果 -- doris就是这个产物。

缺点:
不具有查询原始数据的灵活性。
count distinct指标查询性能弱，即使有bitmap的数据结构做辅助，也有查询性能慢、吃内存的问题。


