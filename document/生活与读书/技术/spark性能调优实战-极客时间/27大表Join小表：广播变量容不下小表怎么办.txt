一、背景与总结


二、案例1：Join Key(on需要关联的key)远大于Payload(度量指标)
1.简单描述一下背景
a.流量表数据内容:性别、年龄、城市、渠道1、渠道2、渠道3、小时、访问量。
b.流量表1大小100G，流量表2大小10G
c.查询sql如下:
select 流量表1.*,coalesce(流量表1.访问量, 流量表2.访问量) as 访问量
from 流量表1
left join 流量表2
on 流量表1.性别 = 流量表2.性别
and 流量表1.年龄 = 流量表2.年龄
and 流量表1.城市 = 流量表2.城市
and 流量表1.渠道1 = 流量表2.渠道1
and 流量表1.渠道2 = 流量表2.渠道2
and 流量表1.渠道3 = 流量表2.渠道3
and 流量表1.小时 = 流量表2.小时

2.案例特征。
a.两个表都很大，不能用广播。
b.on条件多,但指标相对少，案例中就1个指标。

3.解决方案
a.流量表1和流量表2,分别增加一个字段,叫Hash Key,即分别将on内需要的条件,拼装成字符串,进行hash处理。哈希算法（如MD5或SHA256）
b.修改sql
select 流量表1.*,coalesce(流量表1.访问量, 流量表2.访问量) as 访问量
from 流量表1
left join 流量表2
on 流量表1.HashKey = 流量表2.HashKey
c.查询流量表2的时候，不需要查询相关很多字段，只需要带上HashKey以及对应的指标即可。

d.经过如上处理后,流量表2由原来的10G,转换成1.5G，此时调整广播join配置，或者强制广播的方式,即可完成Shuffle Join到Broadcast Join的转化。

4.优化
hash可能会冲突，因此就会破坏原有的关联关系。比如，本来两个不相等的Join Keys，因为哈希值恰巧相同而被关联到了一起。

解决方法:
在两种不同哈希算法运算下的结果完全相同，这种概率几乎为零。
因此我们用两种不同的hash算法,（如MD5或SHA256）对拼接后的字符串创建hashKey,然后将两个hashKey结果拼接(或者直接分别存储2个字段中,on条件是2个字段同时相等),作为on的条件。


三、案例2：过滤条件的Selectivity较高
1.背景介绍
统计所有头部用户贡献的营业额，并按照营业额倒序排序。
相当于订单表 join 用户表，where 用户是头部用户的。
由于头部用户占比不多，所以很容易可以容纳到广播join里。

2.解决方法
a.使用AQE,在运行时动态地调整Join策略。利用该特性实现。
打开AQE  set spark.sql.adaptive.enabled=true
b.统计符合条件的用户维度表的数据体量，然后修改广播阈值。
设置广播阈值 spark.sql.autoBroadcastJoinThreshold

3.基于DPP进一步优化。
因为DPP可以减少事实表扫描量,提升性能，而且DPP并不需要配置什么，只要满足即可触发。
a.纬度表可以放到广播里，因为满足广播阈值范围以为。---- 这点满足
b.等值关联。---- 这点满足
c.订单事实表,必须按照user_id分区 --- 暂时不满足,但可以做到。
只需重新创建一个基于user_id做分区的新表即可。


你可能会说：“为了利用DPP，重新建表、灌表，这样也需要花费不少时间啊！这不是相当于把运行时间从查询转嫁到建表、灌数了吗？”。你说的没错，确实是这么回事。
如果为了查询效果，临时再去修改表结构、迁移数据确实划不来，属于“临时抱佛脚”。
因此，为了最大限度地利用DPP，在做数仓规划的时候，开发者就应该结合常用查询与典型场景，提前做好表结构的设计，这至少包括Schema、分区键、存储格式等等。

四、案例3：小表数据分布均匀
1.背景介绍
总是有一些顽固的任务，他是无论如何也不能被过滤掉，然后存储到广播里的。
我们知道sortMergeJoin是有排序过程的，这个非常耗时，但shuffleHashJoin不需要排序，只要内存可以装得下，join效率比sortMergeJoin高。
而当数据分布均匀，没有发生倾斜时，一般情况下都是可以在内存满足条件做shuffleHashJoin的。

因此使用shuffleHashJoin代替sortMergeJoin也是一种优化方案。

2.添加Join hints之后的查询语句
select /*+ shuffle_hash(orders) */ (orders.price * order.quantity) as revenue, users.name
from orders inner join users on orders.userId = users.id
group by users.name

需要注意的是，SHJ要想成功地完成计算、不抛OOM异常，需要保证小表的每个数据分片都能放进内存。
这也是为什么，我们要求小表的数据分布必须是均匀的。如果小表存在数据倾斜的问题，那么倾斜分区的OOM将会是一个大概率事件，SHJ的计算也会因此而中断。

