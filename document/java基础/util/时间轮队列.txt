一、总结
1.性能高。
时间轮算法的插入删除时间复杂度是O(1)。
可以看出延迟任务的实现都不是很精确的，并且或多或少都会有阻塞的情况，即使你异步执行，线程不够的情况下还是会阻塞。



1.组成形式

环形数组(每个元素称之为槽)。槽位本身也指代时间精度，比如一秒扫一个槽，那么这个时间轮的最高精度就是 1 秒。每一个槽 = 双向链表(添加和删除的链表操作时间复杂度都是 O(1)),存储待执行任务。 ---- 每一个task指向上一个task与下一个task。因此复杂度是O(1)。

2.add方法

假设槽位是8

比如要加入一个延时5s的任务，5%8,即放到下标5的槽中，存储到对应双向链表的尾部。

比如要加入一个延时50s的任务，50%8,即放到下标2的槽中，存储到对应双向链表的尾部。 ---- 很明显是有问题的，指针移动到到槽2时，不应该执行50s后的任务。

3.扩容方式

向hashmap一样扩容，这个方案不好。

a.一种是通过增加轮次的概念。50 % 8 + 1 = 3，即下标是 2 的位置。然后 50 / 8 = 6，即轮数记为 6。也就是说当循环 6 轮之后扫到下标的 2 的这个槽位会触发这个任务。

Netty 中的 HashedWheelTimer 使用的就是这种方式。

b.多层次的时间轮，这个和我们的手表就更像了，像我们秒针走一圈，分针走一格，分针走一圈，时针走一格。

多层次时间轮就是这样实现的。假设上图就是第一层，那么第一层走了一圈，第二层就走一格。

可以得知第二层的一格就是8秒，假设第二层也是 8 个槽，那么第二层走一圈，第三层走一格，可以得知第三层一格就是 64 秒。

多层次时间轮还会有降级的操作，假设一个任务延迟 500 秒执行，那么刚开始加进来肯定是放在第三层的，当时间过了 436 秒后，此时还需要 64 秒就会触发任务的执行，而此时相对而言它就是个延迟 64 秒后的任务，因此它会被降低放在第二层中，第一层还放不下它。再过个 56 秒，相对而言它就是个延迟 8 秒后执行的任务，因此它会再被降级放在第一层中，等待执行。

降级是为了保证时间精度一致性。Kafka内部用的就是多层次的时间轮算法。

3.每秒移动一个槽位，执行该槽位所有的链表内的任务。


-----


