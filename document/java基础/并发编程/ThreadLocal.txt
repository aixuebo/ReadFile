一、背景与总结


二、简单的理解
1.ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。
2.实现非常简单，就是每一个Thread实例内部有一个独立的变量。从而不会影响其他线程使用该变量造成的冲突，即内部变成单线程实例变量。

三、容易出问题的时间点
1.线程创建子线程，子线程在初始化的时候会复制父线程的local变量内容，但复制完成后，父现成local再变更，子线程也无法获取了。
所以有子线程被创建的时候，父子现成之间传递数据会存在问题，谨慎的态度看，不要再父子线程场景中，使用ThreadLocal。
即ThreadLocal最好仅仅使用在线程独自完成任务场景。
2.线程池，此时线程池也相当于子线程，也不适合使用ThreadLocal。
而且线程池内单一的某一个线程，不断被回收用于其他任务，如果子线程的ThreadLocal内存放过多的信息，而没有被回收，也会造成OOM。(老任务已经结束，应该去remove存储的信息,但实际开发中经常被忽略)。

