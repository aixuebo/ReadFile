一、总结
1.从数据库层 到 页面page层链路流转顺序:
dao层，查询数据库，因此返回的结果是PO
service是领域模型层，因此是接收PO对象，转换成DO对象。
control对各DO领域对象做整合，转换成DTO对象传输给前端页面。
前端页面，接收DTO,转换成页面组件需要的vo


反过来也一样:
页面组件添加的vo,转换成DTO, 传输给control，control得到DTO，转换成DO领域模型，领域模型转换成PO存储到关系型数据库。


2.现实上,各存储对象格式是相同的，但理论上每一层要处理的逻辑不同，所以有必要单独对每一层有特殊的命名。
所以现实中并没有独立拆分成这么多对象。统一用的是DO。

二、PO -- persistent object
也称 Entity Objects 实体对象。
持久化对象，即与关系型数据库的表结构完全一致。

三、DO -- domain object
领域对象，从现实世界中抽象的业务实体。
他可能不是与业务数据库一致，所以有单独的命名。

四、DTO -- data tranfer object
数据传输对象,展示层与服务层之间数据传输对象。

五、VO -- view object
视图对象,把某一个页面需要的数据展示出来。

六、疑问解答:
1.既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？
对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别。
DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。

用一个例子来说明可能会比较容易理解：例如:Service层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，
对于Service层来说，它只从语义上定义：1-男性，2-女性，0-未指定，

而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。
但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，

回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，那么service返回 1 2 0 更合适一些，客户端自己根据1 2 0转换即可。即DTO 转换成 VO。
