LSM（log-structed-merge-tree）

一、核心问题解决 随机读写的IO效率问题
1.数据先写入到内存，内存保持一定顺序排序（内存没有寻道速度的问题，随机写的性能得到大幅提升，解决随机写的问题。
2.内存达到阈值后，flush到磁盘上。批量写入存储,代替随机写磁盘问题。此时是顺序写， 此时文件不允许在修改了。
此时key要有布隆过滤器，判断key是否存在该文件中，加速查询。同时key要有索引,加速查询。
3.第2步形成的小文件,要定期做merge操作。合并成大文件
由于第二步的小文件是不允许修改的，所以key更新转换成多个key存储在文件中，只有第一次出现的key才是有效的。所以merge操作才会真实删除数据。
经过merge，可以减少存储，把delete的数据删除掉，同时优化查询速度，因为查询某一个key不需要查询很多小文件了。

二、注意事项
1.Log：在将数据写入LSM内存结构之前，先记录log。
2.内存数据达到阈值后,存储到磁盘,则Log-Structured
3.定期数据merge。
将数据按key排序，在合并不同file、level上的数据时类似merge-join：如果一直保持生成新的文件，不仅写入会造成冗余空间，而且也会大量降低读的性能
4.组成一串tree文件，按照顺序查询每一个文件。



三、为什么要选用LSM tree呢？
B+树（MySQL InnoDB索引）和log型（append）文件操作（数据库WAL日志）是数据读写效率的两个极端。
B+树解决的是磁盘随机读慢的问题，但随机写无法保证效率，因为写入数据时涉及到树的重构。
log型（append）文件操作解决的是磁盘随机写慢的问题，但读时需要遍历整个文件。

B+树读效率高而写效率差；log型文件操作写效率高而读效率差；
因此要在排序和log型文件操作之间做个折中，于是就引入了log-structed merge tree模型，通过名称可以看出LSM既有日志型的文件操作，提升写效率，又在每个sstable中排序，保证了查询效率。

WAL（Write Ahead Log）
顾名思义，就是在实际操作数据前先写日志，便于恢复。WAL在很多数据库中都存在。

四、LSM树的merge Compact策略
1）读放大:读取数据时实际读取的数据量大于真正的数据量。例如在LSM树中需要先在MemTable查看当前key是否存在，不存在继续从SSTable中寻找。
2）写放大:写入数据时实际写入的数据量大于真正的数据量。例如在LSM树中写入时可能触发Compact操作，导致实际写入的数据量远大于该key的数据量。
3）空间放大:数据实际占用的磁盘空间比数据的真正大小更多。上面提到的冗余存储，对于一个key来说，只有最新的那条记录是有效的，而之前的记录都是可以被清理回收的

size-tiered策略保证每层SSTable的大小相近，同时限制每一层SSTable的数量。
每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。
当层数达到一定数量时，最底层的单个SSTable的大小会变得非常大。并且size-tiered策略会导致空间放大比较严重。
即使对于同一层的SSTable，每个key的记录是可能存在多份的，只有当该层的SSTable执行compact操作才会消除这些key的冗余记录。

