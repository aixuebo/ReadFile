想知道留存的用户的周期是什么样子的
比如现在有100万留存用户,但是这些留存用户都是从什么时间点留存下来的呢?
1.每周都有首投用户,随着时间增加,该周的首投用户数量一定在不断减少的,直到流失,即留存为0,说明留存用户少,目前的留存用户都是新注册用户,
如果新注册用户消失了,则留存也就不存在了。
2.每周都有首投用户,随着时间增加,该周的首投用户数量一定在不断减少的,但是一直都有数据存在,即每周都有最终留存用户,说明留存用户多,产品不错,即即使新增用户消失了,留存依然存在。
3.每周都有首投用户,随着时间增加,该周的首投用户数量一定在不断减少的,但是后续又不断提升,说明产品后续优化越来越好了,因此把用户唤醒后,用户粘性较大,更喜欢我们的产品了

注意:
1.三个图都会有阶段性的波形图,即留存用户减少,但是偶尔会增加,又减少,但是所有的数据都是同比增长的,图表上是看不到每个曲线的交叉的
2.查看首投用户量,看曲线是否是指数曲线还是平滑曲线,来判断是否还有增长空间
3.做差法,可以支持任意时间段的数据支持


考察指标
1.首次投资指标,从开始到现在,累计多少投资用户。
该指标的形式是 数据每周都在增长,每周一个数据点
2.再投指标,即从投资开始,到现在依然有存量的用户数。
该指标的形式是 每周有该周-1个点
比如:第2周 有1个点,是第一周首投的用户在第2周的再投人数(留存人数)
比如:第3周 有2个点,是第一周首投的用户在第3周的再投人数(留存人数)、第1-2周首投的用户在第3周的再投人数(留存人数)
比如:第4周 有3个点,是第一周首投的用户在第4周的再投人数(留存人数)、第1-2周首投的用户在第4周的再投人数(留存人数)、第1-3周首投的用户在第4周的再投人数(留存人数)

因此每周只要计算一次数据即可,最终展现出来的是有多少周,就有多少条曲线。
分别表示:
第一周投资的用户在第2周、3、4、5。。。留存人数
第1-2周投资的用户在第3周、4、5。。。留存人数
第1-3周投资的用户在第4周、5、6。。。留存人数


比如:excel的demo
输入表1
userid  	哪周注册的	存量
user1	2016/12/1	100
user2	2016/12/1	200
user3	2016/12/8	300
user4	2016/12/15	400
user5	2016/12/15	40

输入表2
周
2016/12/1
2016/12/8
2016/12/15


在第三周时间点看输出结果
第一周2
第二周3人
第三周4人

过程
"select 2.周,count(userid)
from 1 join 2
where 存量 >=100 and 2.周 >= 1.周
group by 2.周"


周	userid  	哪周注册的	存量
2016/12/1	user1	2016/12/1	100
2016/12/1	user2	2016/12/1	200
2016/12/1	user3	2016/12/8	300
2016/12/1	user4	2016/12/15	400
2016/12/8	user1	2016/12/1	100
2016/12/8	user2	2016/12/1	200
2016/12/8	user3	2016/12/8	300
2016/12/8	user4	2016/12/15	400
2016/12/15	user1	2016/12/1	100
2016/12/15	user2	2016/12/1	200
2016/12/15	user3	2016/12/8	300
2016/12/15	user4	2016/12/15	400


过滤 周>=哪周注册的
周	userid  	哪周注册的	存量
2016/12/1	user1	2016/12/1	100
2016/12/1	user2	2016/12/1	200
2016/12/8	user1	2016/12/1	100
2016/12/8	user2	2016/12/1	200
2016/12/8	user3	2016/12/8	300
2016/12/15	user1	2016/12/1	100
2016/12/15	user2	2016/12/1	200
2016/12/15	user3	2016/12/8	300
2016/12/15	user4	2016/12/15	400

进行group by 周
2016/12/1	2
2016/12/8	3
2016/12/15	4

-----------------
对于任意周作为开始时间,sql为:
SELECT t1.end_date,t1.week_data,t1.user_num-base.user_num
FROM
(
	SELECT end_date,week_data,user_num,2 flag
	FROM biao
	WHERE TYPE = 1
	AND end_date >= '2016-04-07' AND week_data > '2016-03-31'
) t1
INNER JOIN
(
	SELECT end_date,week_data,user_num,1 flag
	FROM biao
	WHERE TYPE = 1
	AND end_date >= '2016-04-07' AND week_data = '2016-03-31'
) base ON t1.end_date = base.end_date
ORDER BY t1.end_date,t1.flag

注意:
biao 结构:
end_date 表示哪周开始跑
week_data 表示历史周
user_num 表示用户数

2016-04-07 表示用户要查询的开始时间
2016-03-31 表示根据开始时间推导出来的上一周的时间,目的是所有的数据要跟这个基础数据做减法,所得得值才是最终的结果

base表表示开始时间的上一周的数据,为基础数据,后续t1的所有数据都要与该base表内的数据做减法


-----------------