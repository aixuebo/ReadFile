
一、底层逻辑
“找到变化，封装变化”，这才是设计模式的底层逻辑。
很多人忽视了这句话，反而去追寻各种模式的招式，遇到实际的问题又找不到合适的设计模式去解决了。

细细品味这句话，再去看23种设计模式，每种设计模式都在应对变化的事，
比如策略模式，具体的策略在变化；
工厂模式，创建的对象在变化；
模板模式，具体模板算法实现在变化。


二、设计模式有七大基本原则：
1.开闭原则（Open Closed Principle，OCP） 对扩展开放，对修改关闭
2.单一职责原则（Single Responsibility Principle, SRP）实现类要职责单一
3.里氏代换原则（Liskov Substitution Principle，LSP）不要破坏继承体系
是继承复用的基石。子类可以扩展父类的功能，但不能改变父类原有的功能。
也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法，提高代码的重用性；
因此在程序当中，如果将一个父类对象替换成它的任意子类对象后，该程序不会发生异常。这也是该原则希望达到的一种理想状态。
因此程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
4.依赖倒转原则（Dependency Inversion Principle，DIP）面向接口编程
程序要依赖于抽象接口，不要依赖于具体实现。
就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合
5.接口隔离原则（Interface Segregation Principle，ISP）设计接口的时候要精简单一
使用多个专门的接口,而不使用单一的总接口,即客户端不应该依赖那些它不需要的接口。
根绝接口隔离原则,当一个接口太大时,我们需要将它分割成一些细小的接口,使用该接口的客户端只需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色,不干不该干的事情。
6.合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
7.最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）降低耦合

三、状态模式与策略模式区别
1.都有context。但目的不同。
a.策略模式中，需要客户端将具体的策略对象传递给context，因此context其实是策略的模板。
因此客户端需要知道所有的策略，所以重心还是在客户端去如何创建具体的策略。
b.状态模式中,重心在服务端，而不是在客户端，服务端持有所有的状态对象集合。


