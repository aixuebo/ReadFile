一、数据库
1.原子性、一致性、隔离性、持久性
2.四种隔离级别:脏读、不可重复度、幻读、串行

脏读:指在一个事务处理过程里读取了另一个未提交的事务中的数据。
不可重复读:指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，
    这是由于在查询间隔，被另一个事务修改并提交了。
幻读:
　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

3.数据库锁----排它锁、共享锁(可以多个对象一起读)

共享锁:多个事务可封锁一个共享页；任何事务都不能修改该页
排他锁:（独占锁，Exclusive Locks)
这个简单，即其它事务既不能读，又不能改排他锁锁定的资源。

4.数据库sql等优化
1.慢查询sql分析
2.mysql -e "show full processlist" | grep -v Sleep | sort -rnk6 在线找到最慢执行的sql有哪些,explain进行检查
3.索引要充分利用,如果利用不好,自然就慢了
4.主键要短、最好是整数
5.主外键类型要一致,防止隐式转换
6.批处理的时候,不要自动提交
7.数据库分区
8.数据库与服务要在同一个网段机房中
9.设置innodb参数


二、分布式
1.分布式锁
a.数据库方式---一个表存储哪个线程 持有哪个方法的锁,每次持有的时候都插入数据信息,插入失败则表示无法获得锁
b.redis实现---判断key是否存在,如果存在则说明无法获得锁,不存在则追加到redis中,并且value是uuid,用于释放锁的时候确定是该锁,然后redis中删除
c.zookeeper实现---在目录下创建一个顺序的文件名字
（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

基于zookeeper临时有序节点可以实现的分布式锁。

大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

来看下Zookeeper能不能解决前面提到的问题。

锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。

非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。

不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。

缺点:
使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。
但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，
那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，
都要动态创建、销毁瞬时节点来实现锁功能。
ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。

https://blog.csdn.net/xlgen157387/article/details/79036337

2.分布式事务---挺难,没这方面经验,基本上基于两阶段提交


三、虚拟机JVM
https://blog.csdn.net/qq_33048603/article/details/52727991
https://www.cnblogs.com/ityouknow/p/5614961.html

“标记-清理”或“标记-整理”

1.堆(最大的一块)、栈(存储调用的栈,每个线程都单独持有一个自由的栈)、方法区(存储静态变量、实例、class)
2.堆:新生代(一个eden,survivor1,survivor2,即s1和s2)、老生代
新创建的对象都在eden区,而新生代比老生代更频繁GC,因此采用不同回收机制。

3.新生代算法--标记--复制算法
当eden内存不足的时候,会触发gc,将还存活的对象存储到s1中
每次将s1和s2不断替换

4.老年代
a.Parallel Scavenge 算法
多线程并行处理,标记还存活的对象,不是复制到s1这种方式,因为老生代数据比较多。
而是采用碎片化整理的方式,将存活的对象进行重新整理

b.Concurrent Mark sweeps
GC调优通常就是为了改善stop-the-world的时间。
在CMS GC开始时的初始标记(initial mark)比较简单，只有靠近类加载器的存活对象会被标记，
因此停顿时间(stop-the-world)比较短暂。

在并发标记(concurrent mark)阶段，由刚被确认和标记过的存活对象所关联的对象将被会跟踪和检测存活状态。
此步骤的不同之处在于有多个线程并行处理此过程。

在重标记(remark)阶段，由并发标记所关联的新增或中止的对象瘵被会检测。
在最后的并发清理(concurrent sweep)阶段，垃圾回收过程被真正执行。
在垃圾回收执行过程中，其他线程依然在执行。

得益于CMS GC的执行方式，在GC期间系统中断时间非常短暂。CMS GC也被称为低延迟GC，

c.Serial收集器,串行收集器是最古老

四、多线程
1.volatile 增加了多线程之间变量的可见性,但是他不支持原子操作
强制从公有堆栈中获取数据,而不是从线程的私有堆栈中获取属性值
只能用在属性上,不能用在方法上。
不需要阻塞,性能比sysch好,但是随着sysch性能的提高,差距越来越小

他不支持原子操作,因此常用于多线程环境下感知变量的变化,而不用于多线程环境下多个线程去更改该值。

2.
class methodA
线程A methodA
线程B methodA

如果methodA是同步方法,则非缩写形式为 sysn(this(aaaa)) methodA,
即 在this(aaaa)这个对象只能同一个时间点由一个线程访问该方法
因此有一个集合map,key是具体对象this(aaaa),value是哪个线程可以操作
还有一个等待集合map,key是具体对象this(aaaa),value是等待的线程List

当堆栈调用sysn的methodA的时候,要查看此时map对象中this(aaaa)的value是否是自己,
如果是或者不存在,则可以直接被线程使用。
如果不是自己,则要加入到等待集合中


对持有的对象this或者其他具体对象,都有wait和notify方法,属于object的
当在同步中,可以使用wait让该线程不再持有该锁,而当该对象的notify被调用的时候,会激活wait等待的线程继续执行。
但是不是会立刻被激活,而是等notify函数体全部执行完后,再释放锁

即map<对象,持有等待的线程集合>
wait向map中添加一个对象,notify的时候从map中找到key对应的集合,从集合中找到一个线程去运行。

wait(long) 表示超过long后 自己就相当于触发一个notify的含义

join(long) 内部调用的是wait(long),因此会短暂的释放锁,后期再获取该锁
而sleep(long) 是不释放锁的,会一直持有该锁,只是暂时释放cpu而已

join(long)或者join期间,如果线程被interrupted了,只是该线程被结束了,join等待的线程没有异常,还会继续执行的。
这个时候就会出现没办法等待join前线程的结果的尴尬情况。

lock unlock condition用于多路通知,以前的notify其实相当于只有一个condition,而jdk5以后是可以支持多个condition的


五、kylin
一、cube
1.依赖哪个model
2.设置cube需要的维度 和 度量---从model中选择
维度来自于normal、derved推测
3.设置cube的merge周期、分区信息
4.设置聚合函数优化---比如10个维度,则是2^10次方中选择
5.设置字段
rowkey就是设置多少个normal维度


优化策略--避免是2^n中组合
每一个字段的组合中 都设置include属性,将属于这个策略组的字段添加进来,方便日后做下面的处理逻辑:
1.必须要有的属性
2.可以推测的列可以不参与组合,比如lookup表中的某一个字段,join后就一定可以得到唯一的值,因此不需要组合
3.继承关系
4.某几个字段必须一同出现 或者 都不出现.因此2^n 变成1种可能


六、日常工作、难度、收获、改进
ETL---发现调度问题影响性能----血统---azakaban---报警监控(弱点,报警不及时,目前采用同比均值算的) ----实时系统(binlog,埋点)
kylin 离线olap
用户画像
流式处理正在规划基于正则表达式规则分析线上异常，配合zipkin打印的链路信息

二、难题
血统开发过程中,依赖关系的复杂,有时候系统会呈现环依赖

三、收获
kylin代码的研究
算法相关实现的了解

四、改进
1.报警平台报警准确性
2.用户画像算法性能上改进


七、hadoop
profile分析
小文件合并
设置多少map完成后在开始执行reduce
设置split溢出比例以及内存--map和reduce
对特定业务设置jvm参数
使用lzo压缩
设置partition,让他均匀分布
使用combiner函数,减少reduce的shuffle传输数据量
设置reduce的抓去线程数
设置map的压缩格式
设置合理的reduce数量
预处理数据很重要,避免每次都重新解析每一行数据,而应该让每一行数据的第一个字节有更多的标识信息


八、stat原则用于描写项目经验
项目经验描述:基于假设前提是,一个人的过去行为能预测他未来的行为,比如一个人经常迟到,那么预测他下次还会迟到。

项目经验方面描写基于star原则:
situation 情景:我当时所面临的情景
task 任务:我当时的任务是什么
action 行动:我采取了什么样的行动
result 结果:我达到了什么样的结果




