一、秒杀系统特点
读多写少、高并发、负载大、如何防止系统超卖

二、基于数据库的乐观锁的实现方式---判断该结果==1,等于1表示true,表示抢购成功
update xxx set num = num-${buy}
where sku=xxx and num >=${buy}

三、大型的互联网不是这么玩的,因为暴露的问题,以及如何优化
1.当大流量来的时候,数据库并发量是瓶颈。
2.传统数据库不是分布式的,虽然程序是分布式的,但是数据库不是分布式的,因此有瓶颈还是在数据库。
3.参见技术文档,前几步可以让并发不会一下子那么大,因为拦截了一部分同时提交的用户,即用户手速没有那么快。
4.使用分布式的redis的同步增长功能,去进行计数器,而不需要操作数据库
5.如果数据量还是很大,则可以考虑使用消息队列进行排队处理,这样系统没有瓶颈,业务数据会不断的流入到消息队列里面进行处理。
6.流程图是一个国美的架构流程图


四、缓存方式实现---memchache是多线程的,redis是单线程的
缓存的增加只是减少了访问数据库的压力,但是最终秒杀系统还是要走数据库的,还是二这步骤执行的逻辑是最终逻辑。
1.先将每一个商品的库存添加到redis中
2.判断是否有库存
每次请求过来请求都从redis里面读取库存,如果库存存在,并且大于请求的购买数量,则进行redis的减法购买数量
3.set redis的库存,因为涉及到库存的初始化 或者 用户取消订单的时候要更新redis


五、易漏补缺
1.页面优化---按钮灰色,让用户几秒内只能点一次
2.代理层---挡住大流量,代理进行拦截
3.应用层---上面讲解的业务上的核心代码---即如何业务上减轻数据库的压力
缓存:接入本地缓存(guava)、远程缓存
限流:smonitor 基于信号量的实现限流
4.数据库层---如何读写分离,分库分表,主从复制
5.三大利器
限流
降级
缓存
6.如果和网站原有应用部署在一起，必然会对现有业务造成冲击，稍有不慎可能导致整个网站瘫痪。因此秒杀服务应该单独一个服务,不影响网站整体
7.网络带宽的问题比超过平时好多倍。
如果秒杀页面的大小为200K，如果最大并发数为10000次，那么需要的网络和服务器带宽是2G（200K×10000）。
这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。
解决方案
秒杀商品页面静态化
将商品描述、参数、详情，全部写到一个静态页面，不用进行程序的逻辑处理，不需访问数据库。
不用部署动态的服务器和数据库服务器。
为了减轻服务器的压力，需要将秒杀商品页面缓存在CDN,同样CDN服务器也需要临时租借带宽。
8.数据分离---防止影响系统正常运行
业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就是已知热点，当真正开始时我们可以提前做好预热。
系统隔离。系统隔离更多是运行时的隔离，可以通过分组部署的方式和另外99%分开。秒杀还申请了单独的域名，目的也是让请求落到不同的集群中。
数据隔离。秒杀所调用的数据大部分都是热数据，比如会启用单独cache集群或MySQL数据库来放热点数据，目前也是不想0.01%的数据影响另外99.99%。
9.基于时间分片削峰---采用回答问题的方式,就是把峰值的下单请求给拉长了，从以前的1s之内延长到2~10s左右.
除了在前端通过答题在用户端进行流量削峰外，在服务端一般通过锁或者队列来控制瞬间请求。




六、实现细节
1.前台是静态的HTML,可以通过CDN部署分发
2.页面有一个计时器,时间到了，访问后台，暴露秒杀地址，即秒杀地址是0点才能知道的,因此非秒杀时间点即使请求了,也没有办法知道返回值的形式,因此机器是没有办法先得到url的规则的
如何控制秒杀商品页面抢购按钮的可用/禁用。
如果页面是动态生成的，每次刷新都要请求服务器，那么势必造成服务端的负载压力。
如果页面是静态页面的话，可以将页面缓存在CDN，反向代理服务器上，甚至用户浏览器上。但是这样，秒杀开始时，用户刷新页面，根本请求不到应用服务器。
解决方案：
使用JS脚本控制，在页面中引用一个JS文件(文件极小)，但是该文件不要被缓存。
该JS的作用是，包含秒杀开始标志，修改样式，生成下单页面的URL及随机参数。
该JS文件不被缓存的做法：xxx.js?v=随机数。
会有一台服务器进行监控(定时上下架)：
当秒杀活动开始时推送该文件。
当秒杀活动结束时推送文件，标示结束标志，修改样式。

3.点击秒杀，前台做出限制，不能再次点击，后台用redis数据库，判断是否还有商品，再通过mysql的存储过程执行秒杀，
3.常见架构
流量到了亿级别，常见站点架构如上：
1）浏览器端，最上层，会执行到一些JS代码
2）站点层，这一层会访问后端数据，拼html页面返回给浏览器
3）服务层，向上游屏蔽底层数据细节
4）数据层，最终的库存是存在这里的，mysql是一个典型
5.优化方向
1）将请求尽量拦截在系统上游：传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，
下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】
2）充分利用缓存：这是一个典型的读多写少的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，非常适合使用缓存四、优化细节
5.1）浏览器层请求拦截
点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载（一个用户点5次，80%的请求是这么多出来的），怎么整？
a）产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求
b）JS层面，限制用户在x秒之内只能提交一次请求
如此限流，80%流量已拦。
5.2）站点层请求拦截与页面缓存---返回的都是缓存的html,因此没有货还是没有货,都是静态的html,不会有任何数据库性能问题
浏览器层的请求拦截，只能拦住小白用户（不过这是99%的用户哟），高端的程序员根本不吃这一套，写个for循环，直接调用你后端的http请求，怎么整？
a）同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面
b）同一个item的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面
如此限流，又有99%的流量会被拦截在站点层
5.3）服务层请求拦截与数据缓存
站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了10w台肉鸡（并且假设买票不需要实名认证），这下uid的限制不行了吧？怎么整？
a）大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？
对于写请求，做请求队列，每次只透有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”
b）对于读请求，还要我说么？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的
如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了
4.4）数据层闲庭信步
到了数据这一层，几乎就没有什么请求了，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。

七、另外一组实现
服务层的优化
上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有100W用户同时抢100台手机，服务层并发请求压力至少为100W。
采用消息队列缓存请求：既然服务层知道库存只有100台手机，那完全没有必要把100W个请求都传递到数据库啊，那么可以先把这些请求都写到消息队列缓存一下，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。
利用缓存应对读请求：对类似于12306等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力。
利用缓存应对写请求：缓存也是可以应对写请求的，比如我们就可以把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。


案例：利用消息中间件和缓存实现简单的秒杀系统
Redis是一个分布式缓存系统，支持多种数据结构，我们可以利用Redis轻松实现一个强大的秒杀系统。
我们可以采用Redis 最简单的key-value数据结构，用一个原子类型的变量值(AtomicInteger)作为key，把用户id作为value，库存数量便是原子变量的最大值。对于每个用户的秒杀，
我们使用 RPUSH key value插入秒杀请求， 当插入的秒杀请求数达到上限时，停止所有后续插入。
然后我们可以在台启动多个工作线程，使用 LPOP key 读取秒杀成功者的用户id，然后再操作数据库做最终的下订单减库存操作。

当然，上面Redis也可以替换成消息中间件如ActiveMQ、RabbitMQ等，也可以将缓存和消息中间件 组合起来，缓存系统负责接收记录用户请求，消息中间件负责将缓存中的请求同步到数据库。

八、京东方案
目前采用Redis集群（16分片）缓存促销信息，例如促销id、促销剩余数、抢次数等，抢的过程中按照促销id散列到对应分片，实时扣减剩余数。当剩余数为0或促销删除，价格恢复原价。
