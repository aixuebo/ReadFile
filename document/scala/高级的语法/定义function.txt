
1.简单的方式
  def getDouble(value:String ) : Double = value.toDouble  已知函数,传入string,返回double
  
  //gt方法返回的是一个函数,而不是具体的执行方法体
  //即传入double的值,返回一个方法体,方法体是string参数,返回boolean。具体方法是将字符串string转换成double后,与参数double对比。
  def gt(lowerBound: Double): String => Boolean = { (value : String) => getDouble(value) > lowerBound }
  
  def main(args: Array[String]): Unit = {
    println(gt(3)) //输出<function1>
  }
 
2.高级版本 -- 多参数
  参数是2个字符串,返回boolean。方法体是如何利用2个参数计算的值 与 double类型的参数值进行比较
  def gt1(lowerBound: Double): (String,String) => Boolean = { (value : String,value1:String) => getDouble(value) + getDouble(value1) > lowerBound }

  def main(args: Array[String]): Unit = {
    println(gt1(3)) //输出 <function2>
    println(gt1(10)("5","6")) // true
  }
   
3.高级版本---泛型
a.泛型定义同一个类型
  定义一个方法,接受一个泛型参数,返回double
  方法体根据参数不同,如何返回double
  def getDouble1[T](value:T) : Double = value match {
    case x: Int => x.toDouble
    case x: Long => x.toDouble
    case x: Float => x.toDouble
    case x: Double => x.toDouble
    case x: String => x.toDouble
    case _ =>
      throw new IllegalArgumentException("error")
  }

  返回一个方法,该方法有2个参数,分别是T,返回boolean类型。
  T取决于具体传入的时候的类型
  def gt[T](lowerBound: Double) : (T,T) => Boolean = { (value:T,value2:T) => getDouble1(value) + getDouble1(value2) > lowerBound }

  def main(args: Array[String]): Unit = {
    println(gt1(3)) //输出 <function2>
    println(gt1(10)("5","6")) // true
  }
 
 b.泛型定义多种类型
   def getDouble1[T](value:T) : Double = value match {
    case x: Int => x.toDouble
    case x: Long => x.toDouble
    case x: Float => x.toDouble
    case x: Double => x.toDouble
    case x: String => x.toDouble
    case _ =>
      throw new IllegalArgumentException("error")
  }

  //定义T和A两种泛型,当具体参数传入进来的时候,T和A就确定了
  def gt[T,A](lowerBound: Double) : (T,A) => Boolean = { (value:T,value2:A) => getDouble1(value) + getDouble1(value2) > lowerBound }

  def main(args: Array[String]): Unit = {
    println(gt(3))
    println(gt(10)("5","6"))
  }
