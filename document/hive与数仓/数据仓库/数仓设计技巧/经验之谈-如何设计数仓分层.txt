一、背景与总结
1.核心
a.fact定义维度、原子指标
b.维度用范式建模,有日周月不同周期的维度表。
c.aggr层，面向过程建模，但依然是明细模型。
建议使用视图的方式，对fact模型/aggr模型进行派生指标建模。作用是指标收口。
d.topic
用于union all的方式收集模型相关的所有明细指标；将topic+dim以view的方式组合，提供给用户查询明细表。
针对80%的用数需求，topic聚合表来预先计算。
e.app直接面向指标需求方。

2.口径收口
原子指标在fact
派生指标在aggr
计算指标在view
维度在dim

二、fact层
1.对接数据源,提供原始数据的快照数据，属于明细模型。
2.对数据进行清洗。
3.范式建模
4.定义维度、原子指标。

三、DIM层
1.范式建模，有主键。
2.存在d、w、m不同时间周期的维度表。
由于不同周期的状态信息不同，比如商家营业状态。有以下几种方式唯一化:取最新数据、对于是否状态永远取是max即可。

四、aggr层
1.传统意义的聚合
面向过程建模。比如商家聚合。
2.个人定义的aggr层,面向过程建模，但依然是明细模型。
a.使用视图的方式，对fact/aggr传统聚合模型，进行派生指标建模。
b.作用是指标收口。
c.注意，此时是明细模型的原因是，可以应对各种场景使用count(distinct)的指标数据；
当然缺点是查询效率慢。此时可以放到topic主题聚合表，或者使用doris的bitmap解决，但这个明细表还是有必要存在的。
3.举例
商家聚合指标表、商品聚合指标表、流量指标表、交易指标表。

五、topic层
1.目标是主题建模
比如商家主题看数据，肯定是希望看到商家所有的指标，包含商家的基础指标、商家交易指标、商家流量指标等。
此时使用的时候，下游大多数场景是left join各种aggr明细表/聚合表。对下游用户使用表有挑战性，sql写不好,性能会很差。

2.主题明细模型
a.使用union all的方式，将所有跟主题有关系的明细模型，都放在一起。
①标注好哪些是维度、哪些是指标(指标应该如何使用)。
②使用范式建模，因为指标是稳定的，维度不稳定，所以使用时，使用范式主键 join 维度表即可。
③为了后期可维护以及查询效率考虑，表需要物化；并且不对外开放，因为后期会增加指标，需要回刷数据，以及调整指标的关系。
指标排序规则是 模型分类 --> sum --> count(distinct)。新增指标会对底表有影响，从而对下游有影响，因此不对外开放。
b.优点
①下游用户，看到表描述，就可以无脑的使用。
②以view的方式，对外开放，同时配合关联dim维度表，下游使用明细表是非常宽的大明细表，非常好用。

c.缺点
①union all了所有相关模型，查询效率肯定会很慢。
②不同用户需求，维度查询的不同，需要创建很多的topic主题表，对模型命名提出挑战。

3.主题聚合模型 --- 传统意义上的topic模型表
a.优点
①查询体验号，预聚合，解决了查询效率慢的问题。
②尽量把日常频繁用到的指标都分类到主题，进行聚合。可以满足80%的用户取数需求。

b.缺点
①定制开发，把常用的指标聚合好，比如商家订单量，商家用户数，但针对count(distinct)指标，提前定制的必须限制在主题维度内，维度不满足需求，则无法使用该聚合模型。此时还是需要借助明细模型开发。

六、app层
1.针对单一需求方开发，仅做dim+topic的整合即可。
2.view整合的结果，直接对接到doris等，避免dim表变化频率高的场景，回刷收到影响。此时回刷只需要回刷view下游即可。
3.针对业务需要的cube开发输出到app层,不允许非需求方使用。

