一、基础知识。
1.grouping sets的字段，在查询的时候要有-1(全部)的搜索框,因此在最外层要做coalesce(id,-1) id处理,因此要确保所有的group by参与的字段，必须不能为null。
因此要有默认值,比如coalesce(batch.batch_id,'未知')。
2.注意,容易出bug:count(distinct(id))、与sum(value) 如果来自不同的表，则结合的时候会存在问题，因此要拆分成两部分，进行union all处理。
即grouping sets使用时,select中不能存在 sum与count distinct。并且 count distinct指标聚合的字段又不相同的时候，不能共同使用。
即最简单的方式，就是每一个非常简单的sql,统一进行一次grouping sets使，---详细参见下面的具体答疑环节解答。
3.最外层group by 维度,其他指标进行sum处理，因为其他指标分别在union all子查询中已经有结果了，注意union all的子查询维度要与最外层的维度相同。

注意:
1.一旦涉及到用户数，那就需要单独在明细层对用户count(distinct(id))去聚合。不能与全局元数据一起使用。容易出现bug。 ---- 参见下面的具体答疑环节解答。

demo:

select 
### 维度
wk_name,
coalesce(batch_id,-1) batch_id,
coalesce(batch_name,'全部') batch_name,
### 维值
sum(user_count) as user_count,
sum(cost) as cost
wk
from
(
    ###用户数
    select 
    a.wk_name,a.wk,
    coalesce(batch_id,-999) batch_id,
    coalesce(batch_id,'未知') batch_name,
    count(distinct(user_id)) user_count,
    0 cost
    from 表1
    where dt = ？
    group by wk_name,wk,coalesce(batch_id,-999),coalesce(batch_id,'未知') ### 处理默认值
    grouping sets((wk_name,wk),(wk_name,wk,coalesce(batch_id,-999),coalesce(batch_id,'未知') ))
union all
    ###成本
    select a.wk_name,a.wk,
    coalesce(batch.batch_id,-999) batch_id,
    coalesce(batch.batch_id,'未知') batch_name,
    0 user_count,
    sum(amt) cost
    from 表2
    where dt = ？
    group by wk_name,wk,coalesce(batch_id,-999),coalesce(batch_id,'未知') ### 处理默认值
    grouping sets((wk_name,wk),(wk_name,wk,coalesce(batch_id,-999),coalesce(batch_id,'未知') ))
) a 
group by wk_name,wk,batch_id,batch_name ### 维度保持与union all子查询相同

二、答疑
1.问题:grouping sets 涉及到count(distinct())时,为什么要先单独处理完成后，再union all，否则数据是错误的？
答案:因为去重复比较特殊，他不能直接sum，所以如果不单独处理，则后期处理的就是单纯的sum操作，这样会将重复数据重复计算。
 
 比如错误版本:
 ### 全部参与用户数、某一个城市参与用户数、某一个城市+活动参与用户数
select coalesce(city,'-1') city,
coalesce(act_type,'-1') act_type,
sum(share_usr_num) as share_usr_num,
sum(join_usr_num) as join_usr_num
from
(
     select city1 city,act_type
     count(distinct share_usr_id) as share_usr_num,###城市 + 活动 + 分享活动用户数
     0 as join_usr_num
     from table
     group by city1,act_type
 union all
    select city2 city,act_type
    0 share_usr_num,
    count(distinct join_usr_id) as join_usr_num ### 另外一个城市,城市 + 活动 + 接受活动用户数
    from table
    group by city2,act_type
 ) a
 group by city,act_type
 grouping sets ((),(city),(act_type),(city,act_type))
 
 此时已经按照城市+活动类型分组了，这样的查询是没有问题的，但一旦按照city去查询，忽略活动时，则会进行sum，即一个城市下，同一个用户，参与了不同活动，应该算1个人，则被算成N个人。
 
修改:内部先grouping sets ，外部依然套用 group by ，注意：要确保每一个union all对应的分组维度都是与外层的group by 相同。
select coalesce(city,'-1') city,
coalesce(act_type,'-1') act_type,
sum(share_usr_num) as share_usr_num,
sum(join_usr_num) as join_usr_num
from
(
     select city1 city,act_type
     count(distinct share_usr_id) as share_usr_num,###城市 + 活动 + 分享活动用户数
     0 as join_usr_num
     from table
     group by city1,act_type
     grouping sets ((),(city1),(act_type),(city1,act_type))
 union all
    select city2 city,act_type
    0 share_usr_num,
    count(distinct join_usr_id) as join_usr_num ### 另外一个城市,城市 + 活动 + 接受活动用户数
    from table
    group by city2,act_type
    grouping sets ((),(city2),(act_type),(city2,act_type))
 ) a
 group by city,act_type
 这样的结果是，每一个union all内部都是已经按照grouping sets打散了，因此再sum就不会出问题了。