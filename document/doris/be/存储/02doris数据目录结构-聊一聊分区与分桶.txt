一、背景与总结
1.目录结构
table --> Partition --> Bucket形成Tablet具体文件。
因此每一个分区有多少个分桶是固定值，就表示有多少个文件。Tablet文件就是高可用副本的迁移单位。

2.一个表里有多少个文件 = Partition数量 * 分桶数 * 副本数。

3.多少分桶数是合理的。
实际上单个分桶即 Tablet 的数据量理论上没有上下界，但建议在 1GB - 10GB 的范围内，即假设分区大小为 20GB，那么分桶个数设置为 10-20 个是合适的。
即建议一个分桶的数据量大概是2G左右。

4.分桶列的选择，是在 查询吞吐 和 查询并发 之间的一种权衡
如果多个key一起用于分桶，数据肯定更均匀，但查询条件命中分桶会更难，必须所有条件都参与，所以正常情况下，会查询所有分桶，单个查询的延迟随之降低。不是好的方案。
如果仅选择一个列做分桶，则对应的点查询可以仅触发一个分桶扫描。此时，当多个点查询并发时，这些查询有较大的概率分别触发不同的分桶扫描，各个查询之间的IO影响较小（尤其当不同桶分布在不同磁盘上时），所以这种方式适合高并发的点查询场景




二、数据分片（Sharding）,是分布式的基础思想。
目标让不同的数据分布在不同的机器上，突破单点存储和IO瓶颈，使数据库无限扩展。

1.分区
比如按照日期分区，对用于sql裁剪，减少不必要的数据加载。
同时分区使数据库的增删改查操作更方便。
2.分桶
对key进行hash处理，避免数据倾斜。同时数据按照分桶数形成最小物理文件数。

三、分桶数自动计算的方案原理
1.语法
DISTRIBUTED BY HASH(site) BUCKETS AUTO
properties("estimate_partition_size" = "100G")
参数estimate_partition_size表示一个单分区的数据量。

2.初始分桶推算
int N = 计算N值;//先计算一个分桶数初始值 = estimate_partition_size / 5，因为大概doris有5倍压缩比，比如真实分区100M，其实压缩后只有20M。而分桶装多少数据量，提现到是压缩后存储的数据量。
如果结果<100M,分桶数 = 1
如果结果<1024M,分桶数 = 2
否则平均1G分配一个分桶。

int M = 计算M值; //表示磁盘空间一共允许有多少个总分桶数是合理的，即考虑压缩性，每50G的磁盘空间划分一个分桶用于存储分桶文件是合理的，那磁盘空间一共允许有多少个桶 。
根据 BE 节点数以及每个 BE 节点的磁盘容量，计算出桶数 M ，原则是每50G磁盘表示1个单位，因此M = BE节点数 * 磁盘数 *（一块磁盘大小/50G）

int y = BE节点个数;
int x = min(M, N, 128);//先计算一个中间值。基本上N 一定小于M，所以结果就是N，除非N>128个桶，则默认值给128个桶作为上限。

if (x < N && x < y) { //如果最终分桶数比BE节点数少，则分配节点数个分桶，即每一个分桶在一个节点上。比如一共分10个桶，但节点有20个，则扩大分桶数，让每一个节点都给一个分桶。
  return y;
}
return x; //如果分桶数比节点数多，那就尊重事实，每一个节点可以放多个分桶。（大多数都是走到这个逻辑里了）

3.后续分桶数
上述是关于初始分桶的计算逻辑，后续分桶数因为已经有了一定的分区数据，可以根据已有的分区数据量来进行评估。
后续分桶数会根据最多前 7 个分区数据量的 EMA[1]（短期指数移动平均线）值，作为estimate_partition_size 进行评估。此时计算分桶有两种计算方式，假设以天来分区，往前数第一天分区大小为 S7，往前数第二天分区大小为 S6，依次类推到 S1；

4.由于每一个分区的分桶数是不同的，所以元数据保存很重要。
查询sql的时候会根据分区找对应的分桶数，从而获取到具体key对应的分桶，进行查询。

5.应用
select * from test_tbl where sdate = "2020-03-23"  and site = 1
查询某个分区，并且获取该分区对应的site = 1的分桶，查询该分桶。

现实是很多场景下，不会只查询某一个分桶。所以会扫描整个分区。

